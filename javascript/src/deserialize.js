/*----------------------------------------------------------------------------*/
/* This file is generated by the templates/template.rb script and should not  */
/* be modified manually. See                                                  */
/* templates/javascript/src/deserialize.js.erb                                */
/* if you are looking to modify the                                           */
/* template                                                                   */
/*----------------------------------------------------------------------------*/

import * as nodes from "./nodes.js";

const MAJOR_VERSION = 0;
const MINOR_VERSION = 30;
const PATCH_VERSION = 0;

// The DataView getFloat64 function takes an optional second argument that
// specifies whether the number is little-endian or big-endian. It does not
// appear to have a native endian mode, so we need to determine the endianness
// of the system at runtime.
const LITTLE_ENDIAN = (() => {
  let uint32 = new Uint32Array([0x11223344]);
  let uint8 = new Uint8Array(uint32.buffer);

  if (uint8[0] === 0x44) {
    return true;
  } else if (uInt8[0] === 0x11) {
    return false;
  } else {
    throw new Error("Mixed endianness");
  }
})();

class SerializationBuffer {
  FORCED_UTF8_ENCODING_FLAG = 1 << 2;
  FORCED_BINARY_ENCODING_FLAG = 1 << 3;

  DECODER_MAP = new Map([
    ["ascii-8bit", "ascii"]
  ]);

  constructor(source, array) {
    this.source = source;
    this.array = array;
    this.index = 0;
    this.fileEncoding = "utf-8";
    this.decoders = new Map();
  }

  readByte() {
    const result = this.array[this.index];
    this.index += 1;
    return result;
  }

  readBytes(length) {
    const result = this.array.slice(this.index, this.index + length);
    this.index += length;
    return result;
  }

  readString(length, flags) {
    return this.decodeString(this.readBytes(length), flags).value;
  }

  // Read a 32-bit unsigned integer in little-endian format.
  readUint32() {
    const result = this.scanUint32(this.index);
    this.index += 4;
    return result;
  }

  scanUint32(offset) {
    const bytes = this.array.slice(offset, offset + 4);
    return bytes[0] | (bytes[1] << 8) | (bytes[2] << 16) | (bytes[3] << 24);
  }

  readVarInt() {
    let result = 0;
    let shift = 0;

    while (true) {
      const byte = this.readByte();
      result += (byte & 0x7f) << shift;
      shift += 7;

      if ((byte & 0x80) === 0) {
        break;
      }
    }

    return result;
  }

  readLocation() {
    return { startOffset: this.readVarInt(), length: this.readVarInt() };
  }

  readOptionalLocation() {
    if (this.readByte() != 0) {
      return this.readLocation();
    } else {
      return null;
    }
  }

  readStringField(flags) {
    if (flags === undefined) flags = 0;
    const type = this.readByte();

    switch (type) {
      case 1: {
        const startOffset = this.readVarInt();
        const length = this.readVarInt();
        return this.decodeString(this.source.slice(startOffset, startOffset + length), flags);
      }
      case 2:
        return this.decodeString(this.readBytes(this.readVarInt()), flags);
      default:
        throw new Error(`Unknown serialized string type: ${type}`);
    }
  }

  scanConstant(constantPoolOffset, constantIndex) {
    const offset = constantPoolOffset + constantIndex * 8;
    let startOffset = this.scanUint32(offset);
    const length = this.scanUint32(offset + 4);

    if (startOffset & (1 << 31)) {
      startOffset &= (1 << 31) - 1;
      return new TextDecoder().decode(this.array.slice(startOffset, startOffset + length));
    } else {
      return new TextDecoder().decode(this.source.slice(startOffset, startOffset + length));
    }
  }

  readDouble() {
    const view = new DataView(new ArrayBuffer(8));
    for (let index = 0; index < 8; index++) {
      view.setUint8(index, this.readByte());
    }

    return view.getFloat64(0, LITTLE_ENDIAN);
  }

  decodeString(bytes, flags) {
    const forcedBin = (flags & this.FORCED_BINARY_ENCODING_FLAG) !== 0;
    const forcedUtf8 = (flags & this.FORCED_UTF8_ENCODING_FLAG) !== 0;

    if (forcedBin) {
      // just use raw bytes
      return {
        encoding: "ascii",
        validEncoding: true,
        value: this.asciiDecoder.decode(bytes)
      };
    } else {
      const encoding = forcedUtf8 ? "utf-8" : this.fileEncoding.toLowerCase();
      const decoder = this.getDecoder(encoding);

      try {
        // decode with encoding
        return {
          encoding,
          validEncoding: true,
          value: decoder.decode(bytes)
        };
      } catch(e) {
        // just use raw bytes, capture what the encoding should be, set flag saying encoding is invalid
        if (e.code === "ERR_ENCODING_INVALID_ENCODED_DATA") {
          return {
            encoding,
            validEncoding: false,
            value: this.asciiDecoder.decode(bytes)
          };
        }

        throw e;
      }
    }
  }

  getDecoder(encoding) {
    encoding = this.DECODER_MAP.get(encoding) || encoding;

    if (!this.decoders.has(encoding)) {
      this.decoders.set(encoding, new TextDecoder(encoding, {fatal: true}));
    }

    return this.decoders.get(encoding);
  }

  get asciiDecoder() {
    if (!this._asciiDecoder) {
      this._asciiDecoder = new TextDecoder("ascii");
    }

    return this._asciiDecoder;
  }
}

/**
 * A location in the source code.
 *
 * @typedef {{ startOffset: number, length: number }} Location
 */

/**
 * A comment in the source code.
 *
 * @typedef {{ type: number, location: Location }} Comment
 */

/**
 * A magic comment in the source code.
 *
 * @typedef {{ startLocation: Location, endLocation: Location }} MagicComment
 */

/**
 * An error in the source code.
 *
 * @typedef {{ type: string, message: string, location: Location, level: string }} ParseError
 */

/**
 * A warning in the source code.
 *
 * @typedef {{ type: string, message: string, location: Location, level: string }} ParseWarning
 */

/**
 * The result of parsing the source code.
 *
 * @typedef {{ value: ProgramNode, comments: Comment[], magicComments: MagicComment[], errors: ParseError[], warnings: ParseWarning[] }} ParseResult
 */

/**
 * The result of calling parse.
 */
export class ParseResult {
  /**
   * @type {nodes.ProgramNode}
   */
  value;

  /**
   * @type {Comment[]}
   */
  comments;

  /**
   * @type {MagicComment[]}
   */
  magicComments;

  /**
   * @type {Location | null}
   */

  /**
   * @type {ParseError[]}
   */
  errors;

  /**
   * @type {ParseWarning[]}
   */
  warnings;

  /**
   * @param {nodes.ProgramNode} value
   * @param {Comment[]} comments
   * @param {MagicComment[]} magicComments
   * @param {ParseError[]} errors
   * @param {ParseWarning[]} warnings
   */
  constructor(value, comments, magicComments, dataLoc, errors, warnings) {
    this.value = value;
    this.comments = comments;
    this.magicComments = magicComments;
    this.dataLoc = dataLoc;
    this.errors = errors;
    this.warnings = warnings;
  }
}

const errorLevels = ["syntax", "argument", "load"];
const errorTypes = [
  "alias_argument",
  "alias_argument_numbered_reference",
  "ampampeq_multi_assign",
  "argument_after_block",
  "argument_after_forwarding_ellipses",
  "argument_bare_hash",
  "argument_block_forwarding",
  "argument_block_multi",
  "argument_conflict_ampersand",
  "argument_conflict_star",
  "argument_conflict_star_star",
  "argument_formal_class",
  "argument_formal_constant",
  "argument_formal_global",
  "argument_formal_ivar",
  "argument_forwarding_unbound",
  "argument_in",
  "argument_no_forwarding_ampersand",
  "argument_no_forwarding_ellipses",
  "argument_no_forwarding_star",
  "argument_no_forwarding_star_star",
  "argument_splat_after_assoc_splat",
  "argument_splat_after_splat",
  "argument_term_paren",
  "argument_unexpected_block",
  "array_element",
  "array_expression",
  "array_expression_after_star",
  "array_separator",
  "array_term",
  "begin_lonely_else",
  "begin_term",
  "begin_upcase_brace",
  "begin_upcase_term",
  "begin_upcase_toplevel",
  "block_param_local_variable",
  "block_param_pipe_term",
  "block_term_brace",
  "block_term_end",
  "cannot_parse_expression",
  "cannot_parse_string_part",
  "case_expression_after_case",
  "case_expression_after_when",
  "case_match_missing_predicate",
  "case_missing_conditions",
  "case_term",
  "class_in_method",
  "class_name",
  "class_superclass",
  "class_term",
  "class_unexpected_end",
  "class_variable_bare",
  "conditional_elsif_predicate",
  "conditional_if_predicate",
  "conditional_predicate_term",
  "conditional_term",
  "conditional_term_else",
  "conditional_unless_predicate",
  "conditional_until_predicate",
  "conditional_while_predicate",
  "constant_path_colon_colon_constant",
  "def_endless",
  "def_endless_setter",
  "def_name",
  "def_params_term",
  "def_params_term_paren",
  "def_receiver",
  "def_receiver_term",
  "def_term",
  "defined_expression",
  "embdoc_term",
  "embexpr_end",
  "embvar_invalid",
  "end_upcase_brace",
  "end_upcase_term",
  "escape_invalid_control",
  "escape_invalid_control_repeat",
  "escape_invalid_hexadecimal",
  "escape_invalid_meta",
  "escape_invalid_meta_repeat",
  "escape_invalid_unicode",
  "escape_invalid_unicode_cm_flags",
  "escape_invalid_unicode_literal",
  "escape_invalid_unicode_long",
  "escape_invalid_unicode_short",
  "escape_invalid_unicode_term",
  "expect_argument",
  "expect_eol_after_statement",
  "expect_expression_after_ampampeq",
  "expect_expression_after_comma",
  "expect_expression_after_equal",
  "expect_expression_after_less_less",
  "expect_expression_after_lparen",
  "expect_expression_after_operator",
  "expect_expression_after_pipepipeeq",
  "expect_expression_after_question",
  "expect_expression_after_splat",
  "expect_expression_after_splat_hash",
  "expect_expression_after_star",
  "expect_ident_req_parameter",
  "expect_in_delimiter",
  "expect_lparen_req_parameter",
  "expect_message",
  "expect_rbracket",
  "expect_rparen",
  "expect_rparen_after_multi",
  "expect_rparen_req_parameter",
  "expect_string_content",
  "expect_when_delimiter",
  "expression_bare_hash",
  "expression_not_writable",
  "expression_not_writable_encoding",
  "expression_not_writable_false",
  "expression_not_writable_file",
  "expression_not_writable_line",
  "expression_not_writable_nil",
  "expression_not_writable_numbered",
  "expression_not_writable_self",
  "expression_not_writable_true",
  "float_parse",
  "for_collection",
  "for_in",
  "for_index",
  "for_term",
  "global_variable_bare",
  "hash_expression_after_label",
  "hash_key",
  "hash_rocket",
  "hash_term",
  "hash_value",
  "heredoc_identifier",
  "heredoc_term",
  "incomplete_question_mark",
  "incomplete_variable_class",
  "incomplete_variable_class_3_3",
  "incomplete_variable_instance",
  "incomplete_variable_instance_3_3",
  "instance_variable_bare",
  "invalid_block_exit",
  "invalid_character",
  "invalid_encoding_magic_comment",
  "invalid_escape_character",
  "invalid_float_exponent",
  "invalid_local_variable_read",
  "invalid_local_variable_write",
  "invalid_multibyte_char",
  "invalid_multibyte_character",
  "invalid_multibyte_escape",
  "invalid_number_binary",
  "invalid_number_decimal",
  "invalid_number_fraction",
  "invalid_number_hexadecimal",
  "invalid_number_octal",
  "invalid_number_underscore_inner",
  "invalid_number_underscore_trailing",
  "invalid_percent",
  "invalid_percent_eof",
  "invalid_printable_character",
  "invalid_retry_after_else",
  "invalid_retry_after_ensure",
  "invalid_retry_without_rescue",
  "invalid_symbol",
  "invalid_variable_global",
  "invalid_variable_global_3_3",
  "invalid_yield",
  "it_not_allowed_numbered",
  "it_not_allowed_ordinary",
  "lambda_open",
  "lambda_term_brace",
  "lambda_term_end",
  "list_i_lower_element",
  "list_i_lower_term",
  "list_i_upper_element",
  "list_i_upper_term",
  "list_w_lower_element",
  "list_w_lower_term",
  "list_w_upper_element",
  "list_w_upper_term",
  "malloc_failed",
  "mixed_encoding",
  "module_in_method",
  "module_name",
  "module_term",
  "multi_assign_multi_splats",
  "multi_assign_unexpected_rest",
  "no_local_variable",
  "not_expression",
  "number_literal_underscore",
  "numbered_parameter_inner_block",
  "numbered_parameter_it",
  "numbered_parameter_ordinary",
  "numbered_parameter_outer_block",
  "operator_multi_assign",
  "operator_write_arguments",
  "operator_write_block",
  "parameter_assoc_splat_multi",
  "parameter_block_multi",
  "parameter_circular",
  "parameter_forwarding_after_rest",
  "parameter_method_name",
  "parameter_name_duplicated",
  "parameter_no_default",
  "parameter_no_default_kw",
  "parameter_numbered_reserved",
  "parameter_order",
  "parameter_splat_multi",
  "parameter_star",
  "parameter_unexpected_fwd",
  "parameter_unexpected_no_kw",
  "parameter_wild_loose_comma",
  "pattern_array_multiple_rests",
  "pattern_capture_duplicate",
  "pattern_expression_after_bracket",
  "pattern_expression_after_comma",
  "pattern_expression_after_hrocket",
  "pattern_expression_after_in",
  "pattern_expression_after_key",
  "pattern_expression_after_paren",
  "pattern_expression_after_pin",
  "pattern_expression_after_pipe",
  "pattern_expression_after_range",
  "pattern_expression_after_rest",
  "pattern_find_missing_inner",
  "pattern_hash_implicit",
  "pattern_hash_key",
  "pattern_hash_key_duplicate",
  "pattern_hash_key_interpolated",
  "pattern_hash_key_label",
  "pattern_hash_key_locals",
  "pattern_ident_after_hrocket",
  "pattern_label_after_comma",
  "pattern_rest",
  "pattern_term_brace",
  "pattern_term_bracket",
  "pattern_term_paren",
  "pipepipeeq_multi_assign",
  "regexp_encoding_option_mismatch",
  "regexp_incompat_char_encoding",
  "regexp_invalid_unicode_range",
  "regexp_non_escaped_mbc",
  "regexp_parse_error",
  "regexp_term",
  "regexp_unknown_options",
  "regexp_utf8_char_non_utf8_regexp",
  "rescue_expression",
  "rescue_modifier_value",
  "rescue_term",
  "rescue_variable",
  "return_invalid",
  "script_not_found",
  "singleton_for_literals",
  "statement_alias",
  "statement_postexe_end",
  "statement_preexe_begin",
  "statement_undef",
  "string_concatenation",
  "string_interpolated_term",
  "string_literal_eof",
  "string_literal_term",
  "symbol_invalid",
  "symbol_term_dynamic",
  "symbol_term_interpolated",
  "ternary_colon",
  "ternary_expression_false",
  "ternary_expression_true",
  "unary_disallowed",
  "unary_receiver",
  "undef_argument",
  "unexpected_block_argument",
  "unexpected_index_block",
  "unexpected_index_keywords",
  "unexpected_multi_write",
  "unexpected_range_operator",
  "unexpected_safe_navigation",
  "unexpected_token_close_context",
  "unexpected_token_ignore",
  "until_term",
  "void_expression",
  "while_term",
  "write_target_in_method",
  "write_target_readonly",
  "write_target_unexpected",
  "xstring_term",
];

const warningLevels = ["default", "verbose"];
const warningTypes = [
  "ambiguous_binary_operator",
  "ambiguous_first_argument_minus",
  "ambiguous_first_argument_plus",
  "ambiguous_prefix_ampersand",
  "ambiguous_prefix_star",
  "ambiguous_prefix_star_star",
  "ambiguous_slash",
  "comparison_after_comparison",
  "dot_dot_dot_eol",
  "equal_in_conditional",
  "equal_in_conditional_3_3",
  "end_in_method",
  "duplicated_hash_key",
  "duplicated_when_clause",
  "float_out_of_range",
  "ignored_frozen_string_literal",
  "indentation_mismatch",
  "integer_in_flip_flop",
  "invalid_character",
  "invalid_magic_comment_value",
  "invalid_numbered_reference",
  "keyword_eol",
  "literal_in_condition_default",
  "literal_in_condition_verbose",
  "shareable_constant_value_line",
  "shebang_carriage_return",
  "unexpected_carriage_return",
  "unreachable_statement",
  "unused_local_variable",
  "void_statement",
];

/**
 * Accept two Uint8Arrays, one for the source and one for the serialized format.
 * Return the AST corresponding to the serialized form.
 *
 * @param {Uint8Array} source
 * @param {Uint8Array} array
 * @returns {ParseResult}
 * @throws {Error}
 */
export function deserialize(source, array) {
  const buffer = new SerializationBuffer(source, array);

  if (buffer.readString(5) !== "PRISM") {
    throw new Error("Invalid serialization");
  }

  if ((buffer.readByte() != MAJOR_VERSION) || (buffer.readByte() != MINOR_VERSION) || (buffer.readByte() != PATCH_VERSION)) {
    throw new Error("Invalid serialization");
  }

  if (buffer.readByte() != 0) {
    throw new Error("Invalid serialization (location fields must be included but are not)");
  }

  // Read the file's encoding.
  buffer.fileEncoding = buffer.readString(buffer.readVarInt());

  // Skip past the start line, as we don't support that option yet in
  // JavaScript.
  buffer.readVarInt();

  // Skip past the line offsets, as there is no Source object yet in JavaScript.
  // const lineOffsets = Array.from({ length: buffer.readVarInt() }, () => buffer.readVarInt());
  const lineOffsetsCount = buffer.readVarInt();
  for (let i = 0; i < lineOffsetsCount; i ++) {
    buffer.readVarInt();
  }

  const comments = Array.from({ length: buffer.readVarInt() }, () => ({
    type: buffer.readVarInt(),
    location: buffer.readLocation()
  }));

  const magicComments = Array.from({ length: buffer.readVarInt() }, () => ({
    startLocation: buffer.readLocation(),
    endLocation: buffer.readLocation()
  }));

  const dataLoc = buffer.readOptionalLocation();

  const errors = Array.from({ length: buffer.readVarInt() }, () => ({
    type: errorTypes[buffer.readVarInt()],
    message: buffer.readString(buffer.readVarInt()),
    location: buffer.readLocation(),
    level: errorLevels[buffer.readByte()]
  }));

  const warnings = Array.from({ length: buffer.readVarInt() }, () => ({
    type: warningTypes[buffer.readVarInt()],
    message: buffer.readString(buffer.readVarInt()),
    location: buffer.readLocation(),
    level: warningLevels[buffer.readByte()]
  }));

  const constantPoolOffset = buffer.readUint32();
  const constants = Array.from({ length: buffer.readVarInt() }, () => null);

  return new ParseResult(readRequiredNode(), comments, magicComments, dataLoc, errors, warnings);

  function readRequiredNode() {
    const type = buffer.readByte();
    const nodeID = buffer.readVarInt();
    const location = buffer.readLocation();
    let flags;

    switch (type) {
      case 1:
        return new nodes.AliasGlobalVariableNode(nodeID, location, flags = buffer.readVarInt(), readRequiredNode(), readRequiredNode(), buffer.readLocation());
      case 2:
        return new nodes.AliasMethodNode(nodeID, location, flags = buffer.readVarInt(), readRequiredNode(), readRequiredNode(), buffer.readLocation());
      case 3:
        return new nodes.AlternationPatternNode(nodeID, location, flags = buffer.readVarInt(), readRequiredNode(), readRequiredNode(), buffer.readLocation());
      case 4:
        return new nodes.AndNode(nodeID, location, flags = buffer.readVarInt(), readRequiredNode(), readRequiredNode(), buffer.readLocation());
      case 5:
        return new nodes.ArgumentsNode(nodeID, location, flags = buffer.readVarInt(), Array.from({ length: buffer.readVarInt() }, readRequiredNode));
      case 6:
        return new nodes.ArrayNode(nodeID, location, flags = buffer.readVarInt(), Array.from({ length: buffer.readVarInt() }, readRequiredNode), buffer.readOptionalLocation(), buffer.readOptionalLocation());
      case 7:
        return new nodes.ArrayPatternNode(nodeID, location, flags = buffer.readVarInt(), readOptionalNode(), Array.from({ length: buffer.readVarInt() }, readRequiredNode), readOptionalNode(), Array.from({ length: buffer.readVarInt() }, readRequiredNode), buffer.readOptionalLocation(), buffer.readOptionalLocation());
      case 8:
        return new nodes.AssocNode(nodeID, location, flags = buffer.readVarInt(), readRequiredNode(), readRequiredNode(), buffer.readOptionalLocation());
      case 9:
        return new nodes.AssocSplatNode(nodeID, location, flags = buffer.readVarInt(), readOptionalNode(), buffer.readLocation());
      case 10:
        return new nodes.BackReferenceReadNode(nodeID, location, flags = buffer.readVarInt(), readRequiredConstant());
      case 11:
        return new nodes.BeginNode(nodeID, location, flags = buffer.readVarInt(), buffer.readOptionalLocation(), readOptionalNode(), readOptionalNode(), readOptionalNode(), readOptionalNode(), buffer.readOptionalLocation());
      case 12:
        return new nodes.BlockArgumentNode(nodeID, location, flags = buffer.readVarInt(), readOptionalNode(), buffer.readLocation());
      case 13:
        return new nodes.BlockLocalVariableNode(nodeID, location, flags = buffer.readVarInt(), readRequiredConstant());
      case 14:
        return new nodes.BlockNode(nodeID, location, flags = buffer.readVarInt(), Array.from({ length: buffer.readVarInt() }, readRequiredConstant), readOptionalNode(), readOptionalNode(), buffer.readLocation(), buffer.readLocation());
      case 15:
        return new nodes.BlockParameterNode(nodeID, location, flags = buffer.readVarInt(), readOptionalConstant(), buffer.readOptionalLocation(), buffer.readLocation());
      case 16:
        return new nodes.BlockParametersNode(nodeID, location, flags = buffer.readVarInt(), readOptionalNode(), Array.from({ length: buffer.readVarInt() }, readRequiredNode), buffer.readOptionalLocation(), buffer.readOptionalLocation());
      case 17:
        return new nodes.BreakNode(nodeID, location, flags = buffer.readVarInt(), readOptionalNode(), buffer.readLocation());
      case 18:
        return new nodes.CallAndWriteNode(nodeID, location, flags = buffer.readVarInt(), readOptionalNode(), buffer.readOptionalLocation(), buffer.readOptionalLocation(), readRequiredConstant(), readRequiredConstant(), buffer.readLocation(), readRequiredNode());
      case 19:
        return new nodes.CallNode(nodeID, location, flags = buffer.readVarInt(), readOptionalNode(), buffer.readOptionalLocation(), readRequiredConstant(), buffer.readOptionalLocation(), buffer.readOptionalLocation(), readOptionalNode(), buffer.readOptionalLocation(), readOptionalNode());
      case 20:
        return new nodes.CallOperatorWriteNode(nodeID, location, flags = buffer.readVarInt(), readOptionalNode(), buffer.readOptionalLocation(), buffer.readOptionalLocation(), readRequiredConstant(), readRequiredConstant(), readRequiredConstant(), buffer.readLocation(), readRequiredNode());
      case 21:
        return new nodes.CallOrWriteNode(nodeID, location, flags = buffer.readVarInt(), readOptionalNode(), buffer.readOptionalLocation(), buffer.readOptionalLocation(), readRequiredConstant(), readRequiredConstant(), buffer.readLocation(), readRequiredNode());
      case 22:
        return new nodes.CallTargetNode(nodeID, location, flags = buffer.readVarInt(), readRequiredNode(), buffer.readLocation(), readRequiredConstant(), buffer.readLocation());
      case 23:
        return new nodes.CapturePatternNode(nodeID, location, flags = buffer.readVarInt(), readRequiredNode(), readRequiredNode(), buffer.readLocation());
      case 24:
        return new nodes.CaseMatchNode(nodeID, location, flags = buffer.readVarInt(), readOptionalNode(), Array.from({ length: buffer.readVarInt() }, readRequiredNode), readOptionalNode(), buffer.readLocation(), buffer.readLocation());
      case 25:
        return new nodes.CaseNode(nodeID, location, flags = buffer.readVarInt(), readOptionalNode(), Array.from({ length: buffer.readVarInt() }, readRequiredNode), readOptionalNode(), buffer.readLocation(), buffer.readLocation());
      case 26:
        return new nodes.ClassNode(nodeID, location, flags = buffer.readVarInt(), Array.from({ length: buffer.readVarInt() }, readRequiredConstant), buffer.readLocation(), readRequiredNode(), buffer.readOptionalLocation(), readOptionalNode(), readOptionalNode(), buffer.readLocation(), readRequiredConstant());
      case 27:
        return new nodes.ClassVariableAndWriteNode(nodeID, location, flags = buffer.readVarInt(), readRequiredConstant(), buffer.readLocation(), buffer.readLocation(), readRequiredNode());
      case 28:
        return new nodes.ClassVariableOperatorWriteNode(nodeID, location, flags = buffer.readVarInt(), readRequiredConstant(), buffer.readLocation(), buffer.readLocation(), readRequiredNode(), readRequiredConstant());
      case 29:
        return new nodes.ClassVariableOrWriteNode(nodeID, location, flags = buffer.readVarInt(), readRequiredConstant(), buffer.readLocation(), buffer.readLocation(), readRequiredNode());
      case 30:
        return new nodes.ClassVariableReadNode(nodeID, location, flags = buffer.readVarInt(), readRequiredConstant());
      case 31:
        return new nodes.ClassVariableTargetNode(nodeID, location, flags = buffer.readVarInt(), readRequiredConstant());
      case 32:
        return new nodes.ClassVariableWriteNode(nodeID, location, flags = buffer.readVarInt(), readRequiredConstant(), buffer.readLocation(), readRequiredNode(), buffer.readLocation());
      case 33:
        return new nodes.ConstantAndWriteNode(nodeID, location, flags = buffer.readVarInt(), readRequiredConstant(), buffer.readLocation(), buffer.readLocation(), readRequiredNode());
      case 34:
        return new nodes.ConstantOperatorWriteNode(nodeID, location, flags = buffer.readVarInt(), readRequiredConstant(), buffer.readLocation(), buffer.readLocation(), readRequiredNode(), readRequiredConstant());
      case 35:
        return new nodes.ConstantOrWriteNode(nodeID, location, flags = buffer.readVarInt(), readRequiredConstant(), buffer.readLocation(), buffer.readLocation(), readRequiredNode());
      case 36:
        return new nodes.ConstantPathAndWriteNode(nodeID, location, flags = buffer.readVarInt(), readRequiredNode(), buffer.readLocation(), readRequiredNode());
      case 37:
        return new nodes.ConstantPathNode(nodeID, location, flags = buffer.readVarInt(), readOptionalNode(), readOptionalConstant(), buffer.readLocation(), buffer.readLocation());
      case 38:
        return new nodes.ConstantPathOperatorWriteNode(nodeID, location, flags = buffer.readVarInt(), readRequiredNode(), buffer.readLocation(), readRequiredNode(), readRequiredConstant());
      case 39:
        return new nodes.ConstantPathOrWriteNode(nodeID, location, flags = buffer.readVarInt(), readRequiredNode(), buffer.readLocation(), readRequiredNode());
      case 40:
        return new nodes.ConstantPathTargetNode(nodeID, location, flags = buffer.readVarInt(), readOptionalNode(), readOptionalConstant(), buffer.readLocation(), buffer.readLocation());
      case 41:
        return new nodes.ConstantPathWriteNode(nodeID, location, flags = buffer.readVarInt(), readRequiredNode(), buffer.readLocation(), readRequiredNode());
      case 42:
        return new nodes.ConstantReadNode(nodeID, location, flags = buffer.readVarInt(), readRequiredConstant());
      case 43:
        return new nodes.ConstantTargetNode(nodeID, location, flags = buffer.readVarInt(), readRequiredConstant());
      case 44:
        return new nodes.ConstantWriteNode(nodeID, location, flags = buffer.readVarInt(), readRequiredConstant(), buffer.readLocation(), readRequiredNode(), buffer.readLocation());
      case 45:
        buffer.readUint32();
        return new nodes.DefNode(nodeID, location, flags = buffer.readVarInt(), readRequiredConstant(), buffer.readLocation(), readOptionalNode(), readOptionalNode(), readOptionalNode(), Array.from({ length: buffer.readVarInt() }, readRequiredConstant), buffer.readLocation(), buffer.readOptionalLocation(), buffer.readOptionalLocation(), buffer.readOptionalLocation(), buffer.readOptionalLocation(), buffer.readOptionalLocation());
      case 46:
        return new nodes.DefinedNode(nodeID, location, flags = buffer.readVarInt(), buffer.readOptionalLocation(), readRequiredNode(), buffer.readOptionalLocation(), buffer.readLocation());
      case 47:
        return new nodes.ElseNode(nodeID, location, flags = buffer.readVarInt(), buffer.readLocation(), readOptionalNode(), buffer.readOptionalLocation());
      case 48:
        return new nodes.EmbeddedStatementsNode(nodeID, location, flags = buffer.readVarInt(), buffer.readLocation(), readOptionalNode(), buffer.readLocation());
      case 49:
        return new nodes.EmbeddedVariableNode(nodeID, location, flags = buffer.readVarInt(), buffer.readLocation(), readRequiredNode());
      case 50:
        return new nodes.EnsureNode(nodeID, location, flags = buffer.readVarInt(), buffer.readLocation(), readOptionalNode(), buffer.readLocation());
      case 51:
        return new nodes.FalseNode(nodeID, location, flags = buffer.readVarInt());
      case 52:
        return new nodes.FindPatternNode(nodeID, location, flags = buffer.readVarInt(), readOptionalNode(), readRequiredNode(), Array.from({ length: buffer.readVarInt() }, readRequiredNode), readRequiredNode(), buffer.readOptionalLocation(), buffer.readOptionalLocation());
      case 53:
        return new nodes.FlipFlopNode(nodeID, location, flags = buffer.readVarInt(), readOptionalNode(), readOptionalNode(), buffer.readLocation());
      case 54:
        return new nodes.FloatNode(nodeID, location, flags = buffer.readVarInt(), buffer.readDouble());
      case 55:
        return new nodes.ForNode(nodeID, location, flags = buffer.readVarInt(), readRequiredNode(), readRequiredNode(), readOptionalNode(), buffer.readLocation(), buffer.readLocation(), buffer.readOptionalLocation(), buffer.readLocation());
      case 56:
        return new nodes.ForwardingArgumentsNode(nodeID, location, flags = buffer.readVarInt());
      case 57:
        return new nodes.ForwardingParameterNode(nodeID, location, flags = buffer.readVarInt());
      case 58:
        return new nodes.ForwardingSuperNode(nodeID, location, flags = buffer.readVarInt(), readOptionalNode());
      case 59:
        return new nodes.GlobalVariableAndWriteNode(nodeID, location, flags = buffer.readVarInt(), readRequiredConstant(), buffer.readLocation(), buffer.readLocation(), readRequiredNode());
      case 60:
        return new nodes.GlobalVariableOperatorWriteNode(nodeID, location, flags = buffer.readVarInt(), readRequiredConstant(), buffer.readLocation(), buffer.readLocation(), readRequiredNode(), readRequiredConstant());
      case 61:
        return new nodes.GlobalVariableOrWriteNode(nodeID, location, flags = buffer.readVarInt(), readRequiredConstant(), buffer.readLocation(), buffer.readLocation(), readRequiredNode());
      case 62:
        return new nodes.GlobalVariableReadNode(nodeID, location, flags = buffer.readVarInt(), readRequiredConstant());
      case 63:
        return new nodes.GlobalVariableTargetNode(nodeID, location, flags = buffer.readVarInt(), readRequiredConstant());
      case 64:
        return new nodes.GlobalVariableWriteNode(nodeID, location, flags = buffer.readVarInt(), readRequiredConstant(), buffer.readLocation(), readRequiredNode(), buffer.readLocation());
      case 65:
        return new nodes.HashNode(nodeID, location, flags = buffer.readVarInt(), buffer.readLocation(), Array.from({ length: buffer.readVarInt() }, readRequiredNode), buffer.readLocation());
      case 66:
        return new nodes.HashPatternNode(nodeID, location, flags = buffer.readVarInt(), readOptionalNode(), Array.from({ length: buffer.readVarInt() }, readRequiredNode), readOptionalNode(), buffer.readOptionalLocation(), buffer.readOptionalLocation());
      case 67:
        return new nodes.IfNode(nodeID, location, flags = buffer.readVarInt(), buffer.readOptionalLocation(), readRequiredNode(), buffer.readOptionalLocation(), readOptionalNode(), readOptionalNode(), buffer.readOptionalLocation());
      case 68:
        return new nodes.ImaginaryNode(nodeID, location, flags = buffer.readVarInt(), readRequiredNode());
      case 69:
        return new nodes.ImplicitNode(nodeID, location, flags = buffer.readVarInt(), readRequiredNode());
      case 70:
        return new nodes.ImplicitRestNode(nodeID, location, flags = buffer.readVarInt());
      case 71:
        return new nodes.InNode(nodeID, location, flags = buffer.readVarInt(), readRequiredNode(), readOptionalNode(), buffer.readLocation(), buffer.readOptionalLocation());
      case 72:
        return new nodes.IndexAndWriteNode(nodeID, location, flags = buffer.readVarInt(), readOptionalNode(), buffer.readOptionalLocation(), buffer.readLocation(), readOptionalNode(), buffer.readLocation(), readOptionalNode(), buffer.readLocation(), readRequiredNode());
      case 73:
        return new nodes.IndexOperatorWriteNode(nodeID, location, flags = buffer.readVarInt(), readOptionalNode(), buffer.readOptionalLocation(), buffer.readLocation(), readOptionalNode(), buffer.readLocation(), readOptionalNode(), readRequiredConstant(), buffer.readLocation(), readRequiredNode());
      case 74:
        return new nodes.IndexOrWriteNode(nodeID, location, flags = buffer.readVarInt(), readOptionalNode(), buffer.readOptionalLocation(), buffer.readLocation(), readOptionalNode(), buffer.readLocation(), readOptionalNode(), buffer.readLocation(), readRequiredNode());
      case 75:
        return new nodes.IndexTargetNode(nodeID, location, flags = buffer.readVarInt(), readRequiredNode(), buffer.readLocation(), readOptionalNode(), buffer.readLocation(), readOptionalNode());
      case 76:
        return new nodes.InstanceVariableAndWriteNode(nodeID, location, flags = buffer.readVarInt(), readRequiredConstant(), buffer.readLocation(), buffer.readLocation(), readRequiredNode());
      case 77:
        return new nodes.InstanceVariableOperatorWriteNode(nodeID, location, flags = buffer.readVarInt(), readRequiredConstant(), buffer.readLocation(), buffer.readLocation(), readRequiredNode(), readRequiredConstant());
      case 78:
        return new nodes.InstanceVariableOrWriteNode(nodeID, location, flags = buffer.readVarInt(), readRequiredConstant(), buffer.readLocation(), buffer.readLocation(), readRequiredNode());
      case 79:
        return new nodes.InstanceVariableReadNode(nodeID, location, flags = buffer.readVarInt(), readRequiredConstant());
      case 80:
        return new nodes.InstanceVariableTargetNode(nodeID, location, flags = buffer.readVarInt(), readRequiredConstant());
      case 81:
        return new nodes.InstanceVariableWriteNode(nodeID, location, flags = buffer.readVarInt(), readRequiredConstant(), buffer.readLocation(), readRequiredNode(), buffer.readLocation());
      case 82:
        return new nodes.IntegerNode(nodeID, location, flags = buffer.readVarInt(), readInteger());
      case 83:
        return new nodes.InterpolatedMatchLastLineNode(nodeID, location, flags = buffer.readVarInt(), buffer.readLocation(), Array.from({ length: buffer.readVarInt() }, readRequiredNode), buffer.readLocation());
      case 84:
        return new nodes.InterpolatedRegularExpressionNode(nodeID, location, flags = buffer.readVarInt(), buffer.readLocation(), Array.from({ length: buffer.readVarInt() }, readRequiredNode), buffer.readLocation());
      case 85:
        return new nodes.InterpolatedStringNode(nodeID, location, flags = buffer.readVarInt(), buffer.readOptionalLocation(), Array.from({ length: buffer.readVarInt() }, readRequiredNode), buffer.readOptionalLocation());
      case 86:
        return new nodes.InterpolatedSymbolNode(nodeID, location, flags = buffer.readVarInt(), buffer.readOptionalLocation(), Array.from({ length: buffer.readVarInt() }, readRequiredNode), buffer.readOptionalLocation());
      case 87:
        return new nodes.InterpolatedXStringNode(nodeID, location, flags = buffer.readVarInt(), buffer.readLocation(), Array.from({ length: buffer.readVarInt() }, readRequiredNode), buffer.readLocation());
      case 88:
        return new nodes.ItLocalVariableReadNode(nodeID, location, flags = buffer.readVarInt());
      case 89:
        return new nodes.ItParametersNode(nodeID, location, flags = buffer.readVarInt());
      case 90:
        return new nodes.KeywordHashNode(nodeID, location, flags = buffer.readVarInt(), Array.from({ length: buffer.readVarInt() }, readRequiredNode));
      case 91:
        return new nodes.KeywordRestParameterNode(nodeID, location, flags = buffer.readVarInt(), readOptionalConstant(), buffer.readOptionalLocation(), buffer.readLocation());
      case 92:
        return new nodes.LambdaNode(nodeID, location, flags = buffer.readVarInt(), Array.from({ length: buffer.readVarInt() }, readRequiredConstant), buffer.readLocation(), buffer.readLocation(), buffer.readLocation(), readOptionalNode(), readOptionalNode());
      case 93:
        return new nodes.LocalVariableAndWriteNode(nodeID, location, flags = buffer.readVarInt(), buffer.readLocation(), buffer.readLocation(), readRequiredNode(), readRequiredConstant(), buffer.readVarInt());
      case 94:
        return new nodes.LocalVariableOperatorWriteNode(nodeID, location, flags = buffer.readVarInt(), buffer.readLocation(), buffer.readLocation(), readRequiredNode(), readRequiredConstant(), readRequiredConstant(), buffer.readVarInt());
      case 95:
        return new nodes.LocalVariableOrWriteNode(nodeID, location, flags = buffer.readVarInt(), buffer.readLocation(), buffer.readLocation(), readRequiredNode(), readRequiredConstant(), buffer.readVarInt());
      case 96:
        return new nodes.LocalVariableReadNode(nodeID, location, flags = buffer.readVarInt(), readRequiredConstant(), buffer.readVarInt());
      case 97:
        return new nodes.LocalVariableTargetNode(nodeID, location, flags = buffer.readVarInt(), readRequiredConstant(), buffer.readVarInt());
      case 98:
        return new nodes.LocalVariableWriteNode(nodeID, location, flags = buffer.readVarInt(), readRequiredConstant(), buffer.readVarInt(), buffer.readLocation(), readRequiredNode(), buffer.readLocation());
      case 99:
        return new nodes.MatchLastLineNode(nodeID, location, flags = buffer.readVarInt(), buffer.readLocation(), buffer.readLocation(), buffer.readLocation(), buffer.readStringField(flags));
      case 100:
        return new nodes.MatchPredicateNode(nodeID, location, flags = buffer.readVarInt(), readRequiredNode(), readRequiredNode(), buffer.readLocation());
      case 101:
        return new nodes.MatchRequiredNode(nodeID, location, flags = buffer.readVarInt(), readRequiredNode(), readRequiredNode(), buffer.readLocation());
      case 102:
        return new nodes.MatchWriteNode(nodeID, location, flags = buffer.readVarInt(), readRequiredNode(), Array.from({ length: buffer.readVarInt() }, readRequiredNode));
      case 103:
        return new nodes.MissingNode(nodeID, location, flags = buffer.readVarInt());
      case 104:
        return new nodes.ModuleNode(nodeID, location, flags = buffer.readVarInt(), Array.from({ length: buffer.readVarInt() }, readRequiredConstant), buffer.readLocation(), readRequiredNode(), readOptionalNode(), buffer.readLocation(), readRequiredConstant());
      case 105:
        return new nodes.MultiTargetNode(nodeID, location, flags = buffer.readVarInt(), Array.from({ length: buffer.readVarInt() }, readRequiredNode), readOptionalNode(), Array.from({ length: buffer.readVarInt() }, readRequiredNode), buffer.readOptionalLocation(), buffer.readOptionalLocation());
      case 106:
        return new nodes.MultiWriteNode(nodeID, location, flags = buffer.readVarInt(), Array.from({ length: buffer.readVarInt() }, readRequiredNode), readOptionalNode(), Array.from({ length: buffer.readVarInt() }, readRequiredNode), buffer.readOptionalLocation(), buffer.readOptionalLocation(), buffer.readLocation(), readRequiredNode());
      case 107:
        return new nodes.NextNode(nodeID, location, flags = buffer.readVarInt(), readOptionalNode(), buffer.readLocation());
      case 108:
        return new nodes.NilNode(nodeID, location, flags = buffer.readVarInt());
      case 109:
        return new nodes.NoKeywordsParameterNode(nodeID, location, flags = buffer.readVarInt(), buffer.readLocation(), buffer.readLocation());
      case 110:
        return new nodes.NumberedParametersNode(nodeID, location, flags = buffer.readVarInt(), buffer.readByte());
      case 111:
        return new nodes.NumberedReferenceReadNode(nodeID, location, flags = buffer.readVarInt(), buffer.readVarInt());
      case 112:
        return new nodes.OptionalKeywordParameterNode(nodeID, location, flags = buffer.readVarInt(), readRequiredConstant(), buffer.readLocation(), readRequiredNode());
      case 113:
        return new nodes.OptionalParameterNode(nodeID, location, flags = buffer.readVarInt(), readRequiredConstant(), buffer.readLocation(), buffer.readLocation(), readRequiredNode());
      case 114:
        return new nodes.OrNode(nodeID, location, flags = buffer.readVarInt(), readRequiredNode(), readRequiredNode(), buffer.readLocation());
      case 115:
        return new nodes.ParametersNode(nodeID, location, flags = buffer.readVarInt(), Array.from({ length: buffer.readVarInt() }, readRequiredNode), Array.from({ length: buffer.readVarInt() }, readRequiredNode), readOptionalNode(), Array.from({ length: buffer.readVarInt() }, readRequiredNode), Array.from({ length: buffer.readVarInt() }, readRequiredNode), readOptionalNode(), readOptionalNode());
      case 116:
        return new nodes.ParenthesesNode(nodeID, location, flags = buffer.readVarInt(), readOptionalNode(), buffer.readLocation(), buffer.readLocation());
      case 117:
        return new nodes.PinnedExpressionNode(nodeID, location, flags = buffer.readVarInt(), readRequiredNode(), buffer.readLocation(), buffer.readLocation(), buffer.readLocation());
      case 118:
        return new nodes.PinnedVariableNode(nodeID, location, flags = buffer.readVarInt(), readRequiredNode(), buffer.readLocation());
      case 119:
        return new nodes.PostExecutionNode(nodeID, location, flags = buffer.readVarInt(), readOptionalNode(), buffer.readLocation(), buffer.readLocation(), buffer.readLocation());
      case 120:
        return new nodes.PreExecutionNode(nodeID, location, flags = buffer.readVarInt(), readOptionalNode(), buffer.readLocation(), buffer.readLocation(), buffer.readLocation());
      case 121:
        return new nodes.ProgramNode(nodeID, location, flags = buffer.readVarInt(), Array.from({ length: buffer.readVarInt() }, readRequiredConstant), readRequiredNode());
      case 122:
        return new nodes.RangeNode(nodeID, location, flags = buffer.readVarInt(), readOptionalNode(), readOptionalNode(), buffer.readLocation());
      case 123:
        return new nodes.RationalNode(nodeID, location, flags = buffer.readVarInt(), readInteger(), readInteger());
      case 124:
        return new nodes.RedoNode(nodeID, location, flags = buffer.readVarInt());
      case 125:
        return new nodes.RegularExpressionNode(nodeID, location, flags = buffer.readVarInt(), buffer.readLocation(), buffer.readLocation(), buffer.readLocation(), buffer.readStringField(flags));
      case 126:
        return new nodes.RequiredKeywordParameterNode(nodeID, location, flags = buffer.readVarInt(), readRequiredConstant(), buffer.readLocation());
      case 127:
        return new nodes.RequiredParameterNode(nodeID, location, flags = buffer.readVarInt(), readRequiredConstant());
      case 128:
        return new nodes.RescueModifierNode(nodeID, location, flags = buffer.readVarInt(), readRequiredNode(), buffer.readLocation(), readRequiredNode());
      case 129:
        return new nodes.RescueNode(nodeID, location, flags = buffer.readVarInt(), buffer.readLocation(), Array.from({ length: buffer.readVarInt() }, readRequiredNode), buffer.readOptionalLocation(), readOptionalNode(), readOptionalNode(), readOptionalNode());
      case 130:
        return new nodes.RestParameterNode(nodeID, location, flags = buffer.readVarInt(), readOptionalConstant(), buffer.readOptionalLocation(), buffer.readLocation());
      case 131:
        return new nodes.RetryNode(nodeID, location, flags = buffer.readVarInt());
      case 132:
        return new nodes.ReturnNode(nodeID, location, flags = buffer.readVarInt(), buffer.readLocation(), readOptionalNode());
      case 133:
        return new nodes.SelfNode(nodeID, location, flags = buffer.readVarInt());
      case 134:
        return new nodes.ShareableConstantNode(nodeID, location, flags = buffer.readVarInt(), readRequiredNode());
      case 135:
        return new nodes.SingletonClassNode(nodeID, location, flags = buffer.readVarInt(), Array.from({ length: buffer.readVarInt() }, readRequiredConstant), buffer.readLocation(), buffer.readLocation(), readRequiredNode(), readOptionalNode(), buffer.readLocation());
      case 136:
        return new nodes.SourceEncodingNode(nodeID, location, flags = buffer.readVarInt());
      case 137:
        return new nodes.SourceFileNode(nodeID, location, flags = buffer.readVarInt(), buffer.readStringField(flags));
      case 138:
        return new nodes.SourceLineNode(nodeID, location, flags = buffer.readVarInt());
      case 139:
        return new nodes.SplatNode(nodeID, location, flags = buffer.readVarInt(), buffer.readLocation(), readOptionalNode());
      case 140:
        return new nodes.StatementsNode(nodeID, location, flags = buffer.readVarInt(), Array.from({ length: buffer.readVarInt() }, readRequiredNode));
      case 141:
        return new nodes.StringNode(nodeID, location, flags = buffer.readVarInt(), buffer.readOptionalLocation(), buffer.readLocation(), buffer.readOptionalLocation(), buffer.readStringField(flags));
      case 142:
        return new nodes.SuperNode(nodeID, location, flags = buffer.readVarInt(), buffer.readLocation(), buffer.readOptionalLocation(), readOptionalNode(), buffer.readOptionalLocation(), readOptionalNode());
      case 143:
        return new nodes.SymbolNode(nodeID, location, flags = buffer.readVarInt(), buffer.readOptionalLocation(), buffer.readOptionalLocation(), buffer.readOptionalLocation(), buffer.readStringField(flags));
      case 144:
        return new nodes.TrueNode(nodeID, location, flags = buffer.readVarInt());
      case 145:
        return new nodes.UndefNode(nodeID, location, flags = buffer.readVarInt(), Array.from({ length: buffer.readVarInt() }, readRequiredNode), buffer.readLocation());
      case 146:
        return new nodes.UnlessNode(nodeID, location, flags = buffer.readVarInt(), buffer.readLocation(), readRequiredNode(), buffer.readOptionalLocation(), readOptionalNode(), readOptionalNode(), buffer.readOptionalLocation());
      case 147:
        return new nodes.UntilNode(nodeID, location, flags = buffer.readVarInt(), buffer.readLocation(), buffer.readOptionalLocation(), readRequiredNode(), readOptionalNode());
      case 148:
        return new nodes.WhenNode(nodeID, location, flags = buffer.readVarInt(), buffer.readLocation(), Array.from({ length: buffer.readVarInt() }, readRequiredNode), buffer.readOptionalLocation(), readOptionalNode());
      case 149:
        return new nodes.WhileNode(nodeID, location, flags = buffer.readVarInt(), buffer.readLocation(), buffer.readOptionalLocation(), readRequiredNode(), readOptionalNode());
      case 150:
        return new nodes.XStringNode(nodeID, location, flags = buffer.readVarInt(), buffer.readLocation(), buffer.readLocation(), buffer.readLocation(), buffer.readStringField(flags));
      case 151:
        return new nodes.YieldNode(nodeID, location, flags = buffer.readVarInt(), buffer.readLocation(), buffer.readOptionalLocation(), readOptionalNode(), buffer.readOptionalLocation());
      default:
        throw new Error(`Unknown node type: ${type}`);
    }
  }

  function readOptionalNode() {
    if (buffer.readByte() != 0) {
      buffer.index -= 1;
      return readRequiredNode();
    } else {
      return null;
    }
  }

  function scanConstant(constantIndex) {
    if (constants[constantIndex] === null) {
      constants[constantIndex] = buffer.scanConstant(constantPoolOffset, constantIndex);
    }

    return constants[constantIndex];
  }

  function readRequiredConstant() {
    return scanConstant(buffer.readVarInt() - 1);
  }

  function readOptionalConstant() {
    const index = buffer.readVarInt();
    if (index === 0) {
      return null;
    } else {
      return scanConstant(index - 1);
    }
  }

  function readInteger() {
    const negative = buffer.readByte() != 0;
    const length = buffer.readVarInt();

    const firstWord = buffer.readVarInt();
    if (length == 1) {
      if (negative && firstWord >= 0x80000000) {
        return -BigInt(firstWord);
      } else if (negative) {
        return -firstWord;
      } else {
        return firstWord;
      }
    }

    let result = BigInt(firstWord);
    for (let index = 1; index < length; index++) {
      result |= (BigInt(buffer.readVarInt()) << BigInt(index * 32));
    }

    return negative ? -result : result;
  }
}
