/*----------------------------------------------------------------------------*/
/* This file is generated by the templates/template.rb script and should not  */
/* be modified manually. See                                                  */
/* templates/javascript/src/nodes.js.erb                                      */
/* if you are looking to modify the                                           */
/* template                                                                   */
/*----------------------------------------------------------------------------*/

import * as visitors from "./visitor.js"


/**
 * Flags for arguments nodes.
 */
const ArgumentsNodeFlags = {
  CONTAINS_FORWARDING: 1 << 2,
  CONTAINS_KEYWORDS: 1 << 3,
  CONTAINS_KEYWORD_SPLAT: 1 << 4,
  CONTAINS_SPLAT: 1 << 5,
  CONTAINS_MULTIPLE_SPLATS: 1 << 6,
};

/**
 * Flags for array nodes.
 */
const ArrayNodeFlags = {
  CONTAINS_SPLAT: 1 << 2,
};

/**
 * Flags for call nodes.
 */
const CallNodeFlags = {
  SAFE_NAVIGATION: 1 << 2,
  VARIABLE_CALL: 1 << 3,
  ATTRIBUTE_WRITE: 1 << 4,
  IGNORE_VISIBILITY: 1 << 5,
};

/**
 * Flags for nodes that have unescaped content.
 */
const EncodingFlags = {
  FORCED_UTF8_ENCODING: 1 << 2,
  FORCED_BINARY_ENCODING: 1 << 3,
};

/**
 * Flags for integer nodes that correspond to the base of the integer.
 */
const IntegerBaseFlags = {
  BINARY: 1 << 2,
  DECIMAL: 1 << 3,
  OCTAL: 1 << 4,
  HEXADECIMAL: 1 << 5,
};

/**
 * Flags for interpolated string nodes that indicated mutability if they are also marked as literals.
 */
const InterpolatedStringNodeFlags = {
  FROZEN: 1 << 2,
  MUTABLE: 1 << 3,
};

/**
 * Flags for keyword hash nodes.
 */
const KeywordHashNodeFlags = {
  SYMBOL_KEYS: 1 << 2,
};

/**
 * Flags for while and until loop nodes.
 */
const LoopFlags = {
  BEGIN_MODIFIER: 1 << 2,
};

/**
 * Flags for parameter nodes.
 */
const ParameterFlags = {
  REPEATED_PARAMETER: 1 << 2,
};

/**
 * Flags for range and flip-flop nodes.
 */
const RangeFlags = {
  EXCLUDE_END: 1 << 2,
};

/**
 * Flags for regular expression and match last line nodes.
 */
const RegularExpressionFlags = {
  IGNORE_CASE: 1 << 2,
  EXTENDED: 1 << 3,
  MULTI_LINE: 1 << 4,
  ONCE: 1 << 5,
  EUC_JP: 1 << 6,
  ASCII_8BIT: 1 << 7,
  WINDOWS_31J: 1 << 8,
  UTF_8: 1 << 9,
  FORCED_UTF8_ENCODING: 1 << 10,
  FORCED_BINARY_ENCODING: 1 << 11,
  FORCED_US_ASCII_ENCODING: 1 << 12,
};

/**
 * Flags for shareable constant nodes.
 */
const ShareableConstantNodeFlags = {
  LITERAL: 1 << 2,
  EXPERIMENTAL_EVERYTHING: 1 << 3,
  EXPERIMENTAL_COPY: 1 << 4,
};

/**
 * Flags for string nodes.
 */
const StringFlags = {
  FORCED_UTF8_ENCODING: 1 << 2,
  FORCED_BINARY_ENCODING: 1 << 3,
  FROZEN: 1 << 4,
  MUTABLE: 1 << 5,
};

/**
 * Flags for symbol nodes.
 */
const SymbolFlags = {
  FORCED_UTF8_ENCODING: 1 << 2,
  FORCED_BINARY_ENCODING: 1 << 3,
  FORCED_US_ASCII_ENCODING: 1 << 4,
};

/**
 * A location in the source code.
 *
 * @typedef {{ startOffset: number, length: number }} Location
 */

/**
 * An encoded Ruby string.
 *
 * @typedef {{ value: string, encoding: string, validEncoding: boolean }} RubyString
 */

/**
 * A generic node in the tree.
 *
 * @typedef {(AliasGlobalVariableNode|AliasMethodNode|AlternationPatternNode|AndNode|ArgumentsNode|ArrayNode|ArrayPatternNode|AssocNode|AssocSplatNode|BackReferenceReadNode|BeginNode|BlockArgumentNode|BlockLocalVariableNode|BlockNode|BlockParameterNode|BlockParametersNode|BreakNode|CallAndWriteNode|CallNode|CallOperatorWriteNode|CallOrWriteNode|CallTargetNode|CapturePatternNode|CaseMatchNode|CaseNode|ClassNode|ClassVariableAndWriteNode|ClassVariableOperatorWriteNode|ClassVariableOrWriteNode|ClassVariableReadNode|ClassVariableTargetNode|ClassVariableWriteNode|ConstantAndWriteNode|ConstantOperatorWriteNode|ConstantOrWriteNode|ConstantPathAndWriteNode|ConstantPathNode|ConstantPathOperatorWriteNode|ConstantPathOrWriteNode|ConstantPathTargetNode|ConstantPathWriteNode|ConstantReadNode|ConstantTargetNode|ConstantWriteNode|DefNode|DefinedNode|ElseNode|EmbeddedStatementsNode|EmbeddedVariableNode|EnsureNode|FalseNode|FindPatternNode|FlipFlopNode|FloatNode|ForNode|ForwardingArgumentsNode|ForwardingParameterNode|ForwardingSuperNode|GlobalVariableAndWriteNode|GlobalVariableOperatorWriteNode|GlobalVariableOrWriteNode|GlobalVariableReadNode|GlobalVariableTargetNode|GlobalVariableWriteNode|HashNode|HashPatternNode|IfNode|ImaginaryNode|ImplicitNode|ImplicitRestNode|InNode|IndexAndWriteNode|IndexOperatorWriteNode|IndexOrWriteNode|IndexTargetNode|InstanceVariableAndWriteNode|InstanceVariableOperatorWriteNode|InstanceVariableOrWriteNode|InstanceVariableReadNode|InstanceVariableTargetNode|InstanceVariableWriteNode|IntegerNode|InterpolatedMatchLastLineNode|InterpolatedRegularExpressionNode|InterpolatedStringNode|InterpolatedSymbolNode|InterpolatedXStringNode|ItLocalVariableReadNode|ItParametersNode|KeywordHashNode|KeywordRestParameterNode|LambdaNode|LocalVariableAndWriteNode|LocalVariableOperatorWriteNode|LocalVariableOrWriteNode|LocalVariableReadNode|LocalVariableTargetNode|LocalVariableWriteNode|MatchLastLineNode|MatchPredicateNode|MatchRequiredNode|MatchWriteNode|MissingNode|ModuleNode|MultiTargetNode|MultiWriteNode|NextNode|NilNode|NoKeywordsParameterNode|NumberedParametersNode|NumberedReferenceReadNode|OptionalKeywordParameterNode|OptionalParameterNode|OrNode|ParametersNode|ParenthesesNode|PinnedExpressionNode|PinnedVariableNode|PostExecutionNode|PreExecutionNode|ProgramNode|RangeNode|RationalNode|RedoNode|RegularExpressionNode|RequiredKeywordParameterNode|RequiredParameterNode|RescueModifierNode|RescueNode|RestParameterNode|RetryNode|ReturnNode|SelfNode|ShareableConstantNode|SingletonClassNode|SourceEncodingNode|SourceFileNode|SourceLineNode|SplatNode|StatementsNode|StringNode|SuperNode|SymbolNode|TrueNode|UndefNode|UnlessNode|UntilNode|WhenNode|WhileNode|XStringNode|YieldNode)} Node
 */

/**
 * Represents the use of the `alias` keyword to alias a global variable.
 *
 *     alias $foo $bar
 *     ^^^^^^^^^^^^^^^
 */
export class AliasGlobalVariableNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Node
   */
  newName;

  /**
   * @type Node
   */
  oldName;

  /**
   * @type Location
   */
  keywordLoc;

  /**
   * Construct a new AliasGlobalVariableNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Node} newName
   * @param {Node} oldName
   * @param {Location} keywordLoc
   */
  constructor(nodeID, location, flags, newName, oldName, keywordLoc) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.newName = newName;
    this.oldName = oldName;
    this.keywordLoc = keywordLoc;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitAliasGlobalVariableNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.newName, this.oldName]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [this.newName, this.oldName];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "AliasGlobalVariableNode",
      location: this.location,
      flags: this.#flags,
      newName: this.newName,
      oldName: this.oldName,
      keywordLoc: this.keywordLoc,
    };
  }
}

/**
 * Represents the use of the `alias` keyword to alias a method.
 *
 *     alias foo bar
 *     ^^^^^^^^^^^^^
 */
export class AliasMethodNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Node
   */
  newName;

  /**
   * @type Node
   */
  oldName;

  /**
   * @type Location
   */
  keywordLoc;

  /**
   * Construct a new AliasMethodNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Node} newName
   * @param {Node} oldName
   * @param {Location} keywordLoc
   */
  constructor(nodeID, location, flags, newName, oldName, keywordLoc) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.newName = newName;
    this.oldName = oldName;
    this.keywordLoc = keywordLoc;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitAliasMethodNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.newName, this.oldName]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [this.newName, this.oldName];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "AliasMethodNode",
      location: this.location,
      flags: this.#flags,
      newName: this.newName,
      oldName: this.oldName,
      keywordLoc: this.keywordLoc,
    };
  }
}

/**
 * Represents an alternation pattern in pattern matching.
 *
 *     foo => bar | baz
 *            ^^^^^^^^^
 */
export class AlternationPatternNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Node
   */
  left;

  /**
   * @type Node
   */
  right;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * Construct a new AlternationPatternNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Node} left
   * @param {Node} right
   * @param {Location} operatorLoc
   */
  constructor(nodeID, location, flags, left, right, operatorLoc) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.left = left;
    this.right = right;
    this.operatorLoc = operatorLoc;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitAlternationPatternNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.left, this.right]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [this.left, this.right];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "AlternationPatternNode",
      location: this.location,
      flags: this.#flags,
      left: this.left,
      right: this.right,
      operatorLoc: this.operatorLoc,
    };
  }
}

/**
 * Represents the use of the `&&` operator or the `and` keyword.
 *
 *     left and right
 *     ^^^^^^^^^^^^^^
 */
export class AndNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Node
   */
  left;

  /**
   * @type Node
   */
  right;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * Construct a new AndNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Node} left
   * @param {Node} right
   * @param {Location} operatorLoc
   */
  constructor(nodeID, location, flags, left, right, operatorLoc) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.left = left;
    this.right = right;
    this.operatorLoc = operatorLoc;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitAndNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.left, this.right]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [this.left, this.right];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "AndNode",
      location: this.location,
      flags: this.#flags,
      left: this.left,
      right: this.right,
      operatorLoc: this.operatorLoc,
    };
  }
}

/**
 * Represents a set of arguments to a method or a keyword.
 *
 *     return foo, bar, baz
 *            ^^^^^^^^^^^^^
 */
export class ArgumentsNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Node[]
   */
  arguments_;

  /**
   * Construct a new ArgumentsNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Node[]} arguments_
   */
  constructor(nodeID, location, flags, arguments_) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.arguments_ = arguments_;
  }

  /**
   * True if this node has the CONTAINS_FORWARDING flag.
   *
   * @returns {boolean}
   */
  isContainsForwarding() {
    return (this.#flags & ArgumentsNodeFlags.CONTAINS_FORWARDING) !== 0;
  }

  /**
   * True if this node has the CONTAINS_KEYWORDS flag.
   *
   * @returns {boolean}
   */
  isContainsKeywords() {
    return (this.#flags & ArgumentsNodeFlags.CONTAINS_KEYWORDS) !== 0;
  }

  /**
   * True if this node has the CONTAINS_KEYWORD_SPLAT flag.
   *
   * @returns {boolean}
   */
  isContainsKeywordSplat() {
    return (this.#flags & ArgumentsNodeFlags.CONTAINS_KEYWORD_SPLAT) !== 0;
  }

  /**
   * True if this node has the CONTAINS_SPLAT flag.
   *
   * @returns {boolean}
   */
  isContainsSplat() {
    return (this.#flags & ArgumentsNodeFlags.CONTAINS_SPLAT) !== 0;
  }

  /**
   * True if this node has the CONTAINS_MULTIPLE_SPLATS flag.
   *
   * @returns {boolean}
   */
  isContainsMultipleSplats() {
    return (this.#flags & ArgumentsNodeFlags.CONTAINS_MULTIPLE_SPLATS) !== 0;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitArgumentsNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [...this.arguments_]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [...this.arguments_];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "ArgumentsNode",
      location: this.location,
      flags: this.#flags,
      arguments: this.arguments_,
    };
  }
}

/**
 * Represents an array literal. This can be a regular array using brackets or a special array using % like %w or %i.
 *
 *     [1, 2, 3]
 *     ^^^^^^^^^
 */
export class ArrayNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Node[]
   */
  elements;

  /**
   * @type Location | null
   */
  openingLoc;

  /**
   * @type Location | null
   */
  closingLoc;

  /**
   * Construct a new ArrayNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Node[]} elements
   * @param {Location | null} openingLoc
   * @param {Location | null} closingLoc
   */
  constructor(nodeID, location, flags, elements, openingLoc, closingLoc) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.elements = elements;
    this.openingLoc = openingLoc;
    this.closingLoc = closingLoc;
  }

  /**
   * True if this node has the CONTAINS_SPLAT flag.
   *
   * @returns {boolean}
   */
  isContainsSplat() {
    return (this.#flags & ArrayNodeFlags.CONTAINS_SPLAT) !== 0;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitArrayNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [...this.elements]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [...this.elements];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "ArrayNode",
      location: this.location,
      flags: this.#flags,
      elements: this.elements,
      openingLoc: this.openingLoc,
      closingLoc: this.closingLoc,
    };
  }
}

/**
 * Represents an array pattern in pattern matching.
 *
 *     foo in 1, 2
 *     ^^^^^^^^^^^
 *
 *     foo in [1, 2]
 *     ^^^^^^^^^^^^^
 *
 *     foo in *1
 *     ^^^^^^^^^
 *
 *     foo in Bar[]
 *     ^^^^^^^^^^^^
 *
 *     foo in Bar[1, 2, 3]
 *     ^^^^^^^^^^^^^^^^^^^
 */
export class ArrayPatternNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Node | null
   */
  constant;

  /**
   * @type Node[]
   */
  requireds;

  /**
   * @type Node | null
   */
  rest;

  /**
   * @type Node[]
   */
  posts;

  /**
   * @type Location | null
   */
  openingLoc;

  /**
   * @type Location | null
   */
  closingLoc;

  /**
   * Construct a new ArrayPatternNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Node | null} constant
   * @param {Node[]} requireds
   * @param {Node | null} rest
   * @param {Node[]} posts
   * @param {Location | null} openingLoc
   * @param {Location | null} closingLoc
   */
  constructor(nodeID, location, flags, constant, requireds, rest, posts, openingLoc, closingLoc) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.constant = constant;
    this.requireds = requireds;
    this.rest = rest;
    this.posts = posts;
    this.openingLoc = openingLoc;
    this.closingLoc = closingLoc;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitArrayPatternNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.constant, ...this.requireds, this.rest, ...this.posts]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    const compact = [];

    if (this.constant) {
      compact.push(this.constant);
    }
    compact.concat(this.requireds);
    if (this.rest) {
      compact.push(this.rest);
    }
    compact.concat(this.posts);

    return compact;
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "ArrayPatternNode",
      location: this.location,
      flags: this.#flags,
      constant: this.constant,
      requireds: this.requireds,
      rest: this.rest,
      posts: this.posts,
      openingLoc: this.openingLoc,
      closingLoc: this.closingLoc,
    };
  }
}

/**
 * Represents a hash key/value pair.
 *
 *     { a => b }
 *       ^^^^^^
 */
export class AssocNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Node
   */
  key;

  /**
   * @type Node
   */
  value;

  /**
   * @type Location | null
   */
  operatorLoc;

  /**
   * Construct a new AssocNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Node} key
   * @param {Node} value
   * @param {Location | null} operatorLoc
   */
  constructor(nodeID, location, flags, key, value, operatorLoc) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.key = key;
    this.value = value;
    this.operatorLoc = operatorLoc;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitAssocNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.key, this.value]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [this.key, this.value];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "AssocNode",
      location: this.location,
      flags: this.#flags,
      key: this.key,
      value: this.value,
      operatorLoc: this.operatorLoc,
    };
  }
}

/**
 * Represents a splat in a hash literal.
 *
 *     { **foo }
 *       ^^^^^
 */
export class AssocSplatNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Node | null
   */
  value;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * Construct a new AssocSplatNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Node | null} value
   * @param {Location} operatorLoc
   */
  constructor(nodeID, location, flags, value, operatorLoc) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.value = value;
    this.operatorLoc = operatorLoc;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitAssocSplatNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.value]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    const compact = [];

    if (this.value) {
      compact.push(this.value);
    }

    return compact;
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "AssocSplatNode",
      location: this.location,
      flags: this.#flags,
      value: this.value,
      operatorLoc: this.operatorLoc,
    };
  }
}

/**
 * Represents reading a reference to a field in the previous match.
 *
 *     $'
 *     ^^
 */
export class BackReferenceReadNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type string
   */
  name;

  /**
   * Construct a new BackReferenceReadNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {string} name
   */
  constructor(nodeID, location, flags, name) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.name = name;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitBackReferenceReadNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return []
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "BackReferenceReadNode",
      location: this.location,
      flags: this.#flags,
      name: this.name,
    };
  }
}

/**
 * Represents a begin statement.
 *
 *     begin
 *       foo
 *     end
 *     ^^^^^
 */
export class BeginNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Location | null
   */
  beginKeywordLoc;

  /**
   * @type StatementsNode | null
   */
  statements;

  /**
   * @type RescueNode | null
   */
  rescueClause;

  /**
   * @type ElseNode | null
   */
  elseClause;

  /**
   * @type EnsureNode | null
   */
  ensureClause;

  /**
   * @type Location | null
   */
  endKeywordLoc;

  /**
   * Construct a new BeginNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Location | null} beginKeywordLoc
   * @param {StatementsNode | null} statements
   * @param {RescueNode | null} rescueClause
   * @param {ElseNode | null} elseClause
   * @param {EnsureNode | null} ensureClause
   * @param {Location | null} endKeywordLoc
   */
  constructor(nodeID, location, flags, beginKeywordLoc, statements, rescueClause, elseClause, ensureClause, endKeywordLoc) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.beginKeywordLoc = beginKeywordLoc;
    this.statements = statements;
    this.rescueClause = rescueClause;
    this.elseClause = elseClause;
    this.ensureClause = ensureClause;
    this.endKeywordLoc = endKeywordLoc;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitBeginNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.statements, this.rescueClause, this.elseClause, this.ensureClause]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    const compact = [];

    if (this.statements) {
      compact.push(this.statements);
    }
    if (this.rescueClause) {
      compact.push(this.rescueClause);
    }
    if (this.elseClause) {
      compact.push(this.elseClause);
    }
    if (this.ensureClause) {
      compact.push(this.ensureClause);
    }

    return compact;
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "BeginNode",
      location: this.location,
      flags: this.#flags,
      beginKeywordLoc: this.beginKeywordLoc,
      statements: this.statements,
      rescueClause: this.rescueClause,
      elseClause: this.elseClause,
      ensureClause: this.ensureClause,
      endKeywordLoc: this.endKeywordLoc,
    };
  }
}

/**
 * Represents a block argument using `&`.
 *
 *     bar(&args)
 *     ^^^^^^^^^^
 */
export class BlockArgumentNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Node | null
   */
  expression;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * Construct a new BlockArgumentNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Node | null} expression
   * @param {Location} operatorLoc
   */
  constructor(nodeID, location, flags, expression, operatorLoc) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.expression = expression;
    this.operatorLoc = operatorLoc;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitBlockArgumentNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.expression]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    const compact = [];

    if (this.expression) {
      compact.push(this.expression);
    }

    return compact;
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "BlockArgumentNode",
      location: this.location,
      flags: this.#flags,
      expression: this.expression,
      operatorLoc: this.operatorLoc,
    };
  }
}

/**
 * Represents a block local variable.
 *
 *     a { |; b| }
 *            ^
 */
export class BlockLocalVariableNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type string
   */
  name;

  /**
   * Construct a new BlockLocalVariableNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {string} name
   */
  constructor(nodeID, location, flags, name) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.name = name;
  }

  /**
   * True if this node has the REPEATED_PARAMETER flag.
   *
   * @returns {boolean}
   */
  isRepeatedParameter() {
    return (this.#flags & ParameterFlags.REPEATED_PARAMETER) !== 0;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitBlockLocalVariableNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return []
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "BlockLocalVariableNode",
      location: this.location,
      flags: this.#flags,
      name: this.name,
    };
  }
}

/**
 * Represents a block of ruby code.
 *
 *     [1, 2, 3].each { |i| puts x }
 *                    ^^^^^^^^^^^^^^
 */
export class BlockNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type string[]
   */
  locals;

  /**
   * @type Node | null
   */
  parameters;

  /**
   * @type Node | null
   */
  body;

  /**
   * @type Location
   */
  openingLoc;

  /**
   * @type Location
   */
  closingLoc;

  /**
   * Construct a new BlockNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {string[]} locals
   * @param {Node | null} parameters
   * @param {Node | null} body
   * @param {Location} openingLoc
   * @param {Location} closingLoc
   */
  constructor(nodeID, location, flags, locals, parameters, body, openingLoc, closingLoc) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.locals = locals;
    this.parameters = parameters;
    this.body = body;
    this.openingLoc = openingLoc;
    this.closingLoc = closingLoc;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitBlockNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.parameters, this.body]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    const compact = [];

    if (this.parameters) {
      compact.push(this.parameters);
    }
    if (this.body) {
      compact.push(this.body);
    }

    return compact;
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "BlockNode",
      location: this.location,
      flags: this.#flags,
      locals: this.locals,
      parameters: this.parameters,
      body: this.body,
      openingLoc: this.openingLoc,
      closingLoc: this.closingLoc,
    };
  }
}

/**
 * Represents a block parameter of a method, block, or lambda definition.
 *
 *     def a(&b)
 *           ^^
 *     end
 */
export class BlockParameterNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type string | null
   */
  name;

  /**
   * @type Location | null
   */
  nameLoc;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * Construct a new BlockParameterNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {string | null} name
   * @param {Location | null} nameLoc
   * @param {Location} operatorLoc
   */
  constructor(nodeID, location, flags, name, nameLoc, operatorLoc) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.name = name;
    this.nameLoc = nameLoc;
    this.operatorLoc = operatorLoc;
  }

  /**
   * True if this node has the REPEATED_PARAMETER flag.
   *
   * @returns {boolean}
   */
  isRepeatedParameter() {
    return (this.#flags & ParameterFlags.REPEATED_PARAMETER) !== 0;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitBlockParameterNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return []
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "BlockParameterNode",
      location: this.location,
      flags: this.#flags,
      name: this.name,
      nameLoc: this.nameLoc,
      operatorLoc: this.operatorLoc,
    };
  }
}

/**
 * Represents a block's parameters declaration.
 *
 *     -> (a, b = 1; local) { }
 *        ^^^^^^^^^^^^^^^^^
 *
 *     foo do |a, b = 1; local|
 *            ^^^^^^^^^^^^^^^^^
 *     end
 */
export class BlockParametersNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type ParametersNode | null
   */
  parameters;

  /**
   * @type Node[]
   */
  locals;

  /**
   * @type Location | null
   */
  openingLoc;

  /**
   * @type Location | null
   */
  closingLoc;

  /**
   * Construct a new BlockParametersNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {ParametersNode | null} parameters
   * @param {Node[]} locals
   * @param {Location | null} openingLoc
   * @param {Location | null} closingLoc
   */
  constructor(nodeID, location, flags, parameters, locals, openingLoc, closingLoc) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.parameters = parameters;
    this.locals = locals;
    this.openingLoc = openingLoc;
    this.closingLoc = closingLoc;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitBlockParametersNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.parameters, ...this.locals]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    const compact = [];

    if (this.parameters) {
      compact.push(this.parameters);
    }
    compact.concat(this.locals);

    return compact;
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "BlockParametersNode",
      location: this.location,
      flags: this.#flags,
      parameters: this.parameters,
      locals: this.locals,
      openingLoc: this.openingLoc,
      closingLoc: this.closingLoc,
    };
  }
}

/**
 * Represents the use of the `break` keyword.
 *
 *     break foo
 *     ^^^^^^^^^
 */
export class BreakNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type ArgumentsNode | null
   */
  arguments_;

  /**
   * @type Location
   */
  keywordLoc;

  /**
   * Construct a new BreakNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {ArgumentsNode | null} arguments_
   * @param {Location} keywordLoc
   */
  constructor(nodeID, location, flags, arguments_, keywordLoc) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.arguments_ = arguments_;
    this.keywordLoc = keywordLoc;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitBreakNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.arguments_]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    const compact = [];

    if (this.arguments_) {
      compact.push(this.arguments_);
    }

    return compact;
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "BreakNode",
      location: this.location,
      flags: this.#flags,
      arguments: this.arguments_,
      keywordLoc: this.keywordLoc,
    };
  }
}

/**
 * Represents the use of the `&&=` operator on a call.
 *
 *     foo.bar &&= value
 *     ^^^^^^^^^^^^^^^^^
 */
export class CallAndWriteNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Node | null
   */
  receiver;

  /**
   * @type Location | null
   */
  callOperatorLoc;

  /**
   * @type Location | null
   */
  messageLoc;

  /**
   * @type string
   */
  readName;

  /**
   * @type string
   */
  writeName;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type Node
   */
  value;

  /**
   * Construct a new CallAndWriteNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Node | null} receiver
   * @param {Location | null} callOperatorLoc
   * @param {Location | null} messageLoc
   * @param {string} readName
   * @param {string} writeName
   * @param {Location} operatorLoc
   * @param {Node} value
   */
  constructor(nodeID, location, flags, receiver, callOperatorLoc, messageLoc, readName, writeName, operatorLoc, value) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.receiver = receiver;
    this.callOperatorLoc = callOperatorLoc;
    this.messageLoc = messageLoc;
    this.readName = readName;
    this.writeName = writeName;
    this.operatorLoc = operatorLoc;
    this.value = value;
  }

  /**
   * True if this node has the SAFE_NAVIGATION flag.
   *
   * @returns {boolean}
   */
  isSafeNavigation() {
    return (this.#flags & CallNodeFlags.SAFE_NAVIGATION) !== 0;
  }

  /**
   * True if this node has the VARIABLE_CALL flag.
   *
   * @returns {boolean}
   */
  isVariableCall() {
    return (this.#flags & CallNodeFlags.VARIABLE_CALL) !== 0;
  }

  /**
   * True if this node has the ATTRIBUTE_WRITE flag.
   *
   * @returns {boolean}
   */
  isAttributeWrite() {
    return (this.#flags & CallNodeFlags.ATTRIBUTE_WRITE) !== 0;
  }

  /**
   * True if this node has the IGNORE_VISIBILITY flag.
   *
   * @returns {boolean}
   */
  isIgnoreVisibility() {
    return (this.#flags & CallNodeFlags.IGNORE_VISIBILITY) !== 0;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitCallAndWriteNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.receiver, this.value]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    const compact = [];

    if (this.receiver) {
      compact.push(this.receiver);
    }
    compact.push(this.value);


    return compact;
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "CallAndWriteNode",
      location: this.location,
      flags: this.#flags,
      receiver: this.receiver,
      callOperatorLoc: this.callOperatorLoc,
      messageLoc: this.messageLoc,
      readName: this.readName,
      writeName: this.writeName,
      operatorLoc: this.operatorLoc,
      value: this.value,
    };
  }
}

/**
 * Represents a method call, in all of the various forms that can take.
 *
 *     foo
 *     ^^^
 *
 *     foo()
 *     ^^^^^
 *
 *     +foo
 *     ^^^^
 *
 *     foo + bar
 *     ^^^^^^^^^
 *
 *     foo.bar
 *     ^^^^^^^
 *
 *     foo&.bar
 *     ^^^^^^^^
 */
export class CallNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Node | null
   */
  receiver;

  /**
   * @type Location | null
   */
  callOperatorLoc;

  /**
   * @type string
   */
  name;

  /**
   * @type Location | null
   */
  messageLoc;

  /**
   * @type Location | null
   */
  openingLoc;

  /**
   * @type ArgumentsNode | null
   */
  arguments_;

  /**
   * @type Location | null
   */
  closingLoc;

  /**
   * @type Node | null
   */
  block;

  /**
   * Construct a new CallNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Node | null} receiver
   * @param {Location | null} callOperatorLoc
   * @param {string} name
   * @param {Location | null} messageLoc
   * @param {Location | null} openingLoc
   * @param {ArgumentsNode | null} arguments_
   * @param {Location | null} closingLoc
   * @param {Node | null} block
   */
  constructor(nodeID, location, flags, receiver, callOperatorLoc, name, messageLoc, openingLoc, arguments_, closingLoc, block) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.receiver = receiver;
    this.callOperatorLoc = callOperatorLoc;
    this.name = name;
    this.messageLoc = messageLoc;
    this.openingLoc = openingLoc;
    this.arguments_ = arguments_;
    this.closingLoc = closingLoc;
    this.block = block;
  }

  /**
   * True if this node has the SAFE_NAVIGATION flag.
   *
   * @returns {boolean}
   */
  isSafeNavigation() {
    return (this.#flags & CallNodeFlags.SAFE_NAVIGATION) !== 0;
  }

  /**
   * True if this node has the VARIABLE_CALL flag.
   *
   * @returns {boolean}
   */
  isVariableCall() {
    return (this.#flags & CallNodeFlags.VARIABLE_CALL) !== 0;
  }

  /**
   * True if this node has the ATTRIBUTE_WRITE flag.
   *
   * @returns {boolean}
   */
  isAttributeWrite() {
    return (this.#flags & CallNodeFlags.ATTRIBUTE_WRITE) !== 0;
  }

  /**
   * True if this node has the IGNORE_VISIBILITY flag.
   *
   * @returns {boolean}
   */
  isIgnoreVisibility() {
    return (this.#flags & CallNodeFlags.IGNORE_VISIBILITY) !== 0;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitCallNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.receiver, this.arguments_, this.block]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    const compact = [];

    if (this.receiver) {
      compact.push(this.receiver);
    }
    if (this.arguments_) {
      compact.push(this.arguments_);
    }
    if (this.block) {
      compact.push(this.block);
    }

    return compact;
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "CallNode",
      location: this.location,
      flags: this.#flags,
      receiver: this.receiver,
      callOperatorLoc: this.callOperatorLoc,
      name: this.name,
      messageLoc: this.messageLoc,
      openingLoc: this.openingLoc,
      arguments: this.arguments_,
      closingLoc: this.closingLoc,
      block: this.block,
    };
  }
}

/**
 * Represents the use of an assignment operator on a call.
 *
 *     foo.bar += baz
 *     ^^^^^^^^^^^^^^
 */
export class CallOperatorWriteNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Node | null
   */
  receiver;

  /**
   * @type Location | null
   */
  callOperatorLoc;

  /**
   * @type Location | null
   */
  messageLoc;

  /**
   * @type string
   */
  readName;

  /**
   * @type string
   */
  writeName;

  /**
   * @type string
   */
  binaryOperator;

  /**
   * @type Location
   */
  binaryOperatorLoc;

  /**
   * @type Node
   */
  value;

  /**
   * Construct a new CallOperatorWriteNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Node | null} receiver
   * @param {Location | null} callOperatorLoc
   * @param {Location | null} messageLoc
   * @param {string} readName
   * @param {string} writeName
   * @param {string} binaryOperator
   * @param {Location} binaryOperatorLoc
   * @param {Node} value
   */
  constructor(nodeID, location, flags, receiver, callOperatorLoc, messageLoc, readName, writeName, binaryOperator, binaryOperatorLoc, value) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.receiver = receiver;
    this.callOperatorLoc = callOperatorLoc;
    this.messageLoc = messageLoc;
    this.readName = readName;
    this.writeName = writeName;
    this.binaryOperator = binaryOperator;
    this.binaryOperatorLoc = binaryOperatorLoc;
    this.value = value;
  }

  /**
   * True if this node has the SAFE_NAVIGATION flag.
   *
   * @returns {boolean}
   */
  isSafeNavigation() {
    return (this.#flags & CallNodeFlags.SAFE_NAVIGATION) !== 0;
  }

  /**
   * True if this node has the VARIABLE_CALL flag.
   *
   * @returns {boolean}
   */
  isVariableCall() {
    return (this.#flags & CallNodeFlags.VARIABLE_CALL) !== 0;
  }

  /**
   * True if this node has the ATTRIBUTE_WRITE flag.
   *
   * @returns {boolean}
   */
  isAttributeWrite() {
    return (this.#flags & CallNodeFlags.ATTRIBUTE_WRITE) !== 0;
  }

  /**
   * True if this node has the IGNORE_VISIBILITY flag.
   *
   * @returns {boolean}
   */
  isIgnoreVisibility() {
    return (this.#flags & CallNodeFlags.IGNORE_VISIBILITY) !== 0;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitCallOperatorWriteNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.receiver, this.value]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    const compact = [];

    if (this.receiver) {
      compact.push(this.receiver);
    }
    compact.push(this.value);


    return compact;
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "CallOperatorWriteNode",
      location: this.location,
      flags: this.#flags,
      receiver: this.receiver,
      callOperatorLoc: this.callOperatorLoc,
      messageLoc: this.messageLoc,
      readName: this.readName,
      writeName: this.writeName,
      binaryOperator: this.binaryOperator,
      binaryOperatorLoc: this.binaryOperatorLoc,
      value: this.value,
    };
  }
}

/**
 * Represents the use of the `||=` operator on a call.
 *
 *     foo.bar ||= value
 *     ^^^^^^^^^^^^^^^^^
 */
export class CallOrWriteNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Node | null
   */
  receiver;

  /**
   * @type Location | null
   */
  callOperatorLoc;

  /**
   * @type Location | null
   */
  messageLoc;

  /**
   * @type string
   */
  readName;

  /**
   * @type string
   */
  writeName;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type Node
   */
  value;

  /**
   * Construct a new CallOrWriteNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Node | null} receiver
   * @param {Location | null} callOperatorLoc
   * @param {Location | null} messageLoc
   * @param {string} readName
   * @param {string} writeName
   * @param {Location} operatorLoc
   * @param {Node} value
   */
  constructor(nodeID, location, flags, receiver, callOperatorLoc, messageLoc, readName, writeName, operatorLoc, value) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.receiver = receiver;
    this.callOperatorLoc = callOperatorLoc;
    this.messageLoc = messageLoc;
    this.readName = readName;
    this.writeName = writeName;
    this.operatorLoc = operatorLoc;
    this.value = value;
  }

  /**
   * True if this node has the SAFE_NAVIGATION flag.
   *
   * @returns {boolean}
   */
  isSafeNavigation() {
    return (this.#flags & CallNodeFlags.SAFE_NAVIGATION) !== 0;
  }

  /**
   * True if this node has the VARIABLE_CALL flag.
   *
   * @returns {boolean}
   */
  isVariableCall() {
    return (this.#flags & CallNodeFlags.VARIABLE_CALL) !== 0;
  }

  /**
   * True if this node has the ATTRIBUTE_WRITE flag.
   *
   * @returns {boolean}
   */
  isAttributeWrite() {
    return (this.#flags & CallNodeFlags.ATTRIBUTE_WRITE) !== 0;
  }

  /**
   * True if this node has the IGNORE_VISIBILITY flag.
   *
   * @returns {boolean}
   */
  isIgnoreVisibility() {
    return (this.#flags & CallNodeFlags.IGNORE_VISIBILITY) !== 0;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitCallOrWriteNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.receiver, this.value]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    const compact = [];

    if (this.receiver) {
      compact.push(this.receiver);
    }
    compact.push(this.value);


    return compact;
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "CallOrWriteNode",
      location: this.location,
      flags: this.#flags,
      receiver: this.receiver,
      callOperatorLoc: this.callOperatorLoc,
      messageLoc: this.messageLoc,
      readName: this.readName,
      writeName: this.writeName,
      operatorLoc: this.operatorLoc,
      value: this.value,
    };
  }
}

/**
 * Represents assigning to a method call.
 *
 *     foo.bar, = 1
 *     ^^^^^^^
 *
 *     begin
 *     rescue => foo.bar
 *               ^^^^^^^
 *     end
 *
 *     for foo.bar in baz do end
 *         ^^^^^^^
 */
export class CallTargetNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Node
   */
  receiver;

  /**
   * @type Location
   */
  callOperatorLoc;

  /**
   * @type string
   */
  name;

  /**
   * @type Location
   */
  messageLoc;

  /**
   * Construct a new CallTargetNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Node} receiver
   * @param {Location} callOperatorLoc
   * @param {string} name
   * @param {Location} messageLoc
   */
  constructor(nodeID, location, flags, receiver, callOperatorLoc, name, messageLoc) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.receiver = receiver;
    this.callOperatorLoc = callOperatorLoc;
    this.name = name;
    this.messageLoc = messageLoc;
  }

  /**
   * True if this node has the SAFE_NAVIGATION flag.
   *
   * @returns {boolean}
   */
  isSafeNavigation() {
    return (this.#flags & CallNodeFlags.SAFE_NAVIGATION) !== 0;
  }

  /**
   * True if this node has the VARIABLE_CALL flag.
   *
   * @returns {boolean}
   */
  isVariableCall() {
    return (this.#flags & CallNodeFlags.VARIABLE_CALL) !== 0;
  }

  /**
   * True if this node has the ATTRIBUTE_WRITE flag.
   *
   * @returns {boolean}
   */
  isAttributeWrite() {
    return (this.#flags & CallNodeFlags.ATTRIBUTE_WRITE) !== 0;
  }

  /**
   * True if this node has the IGNORE_VISIBILITY flag.
   *
   * @returns {boolean}
   */
  isIgnoreVisibility() {
    return (this.#flags & CallNodeFlags.IGNORE_VISIBILITY) !== 0;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitCallTargetNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.receiver]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [this.receiver];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "CallTargetNode",
      location: this.location,
      flags: this.#flags,
      receiver: this.receiver,
      callOperatorLoc: this.callOperatorLoc,
      name: this.name,
      messageLoc: this.messageLoc,
    };
  }
}

/**
 * Represents assigning to a local variable in pattern matching.
 *
 *     foo => [bar => baz]
 *            ^^^^^^^^^^^^
 */
export class CapturePatternNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Node
   */
  value;

  /**
   * @type LocalVariableTargetNode
   */
  target;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * Construct a new CapturePatternNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Node} value
   * @param {LocalVariableTargetNode} target
   * @param {Location} operatorLoc
   */
  constructor(nodeID, location, flags, value, target, operatorLoc) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.value = value;
    this.target = target;
    this.operatorLoc = operatorLoc;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitCapturePatternNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.value, this.target]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [this.value, this.target];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "CapturePatternNode",
      location: this.location,
      flags: this.#flags,
      value: this.value,
      target: this.target,
      operatorLoc: this.operatorLoc,
    };
  }
}

/**
 * Represents the use of a case statement for pattern matching.
 *
 *     case true
 *     in false
 *     end
 *     ^^^^^^^^^
 */
export class CaseMatchNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Node | null
   */
  predicate;

  /**
   * @type Node[]
   */
  conditions;

  /**
   * @type ElseNode | null
   */
  elseClause;

  /**
   * @type Location
   */
  caseKeywordLoc;

  /**
   * @type Location
   */
  endKeywordLoc;

  /**
   * Construct a new CaseMatchNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Node | null} predicate
   * @param {Node[]} conditions
   * @param {ElseNode | null} elseClause
   * @param {Location} caseKeywordLoc
   * @param {Location} endKeywordLoc
   */
  constructor(nodeID, location, flags, predicate, conditions, elseClause, caseKeywordLoc, endKeywordLoc) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.predicate = predicate;
    this.conditions = conditions;
    this.elseClause = elseClause;
    this.caseKeywordLoc = caseKeywordLoc;
    this.endKeywordLoc = endKeywordLoc;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitCaseMatchNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.predicate, ...this.conditions, this.elseClause]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    const compact = [];

    if (this.predicate) {
      compact.push(this.predicate);
    }
    compact.concat(this.conditions);
    if (this.elseClause) {
      compact.push(this.elseClause);
    }

    return compact;
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "CaseMatchNode",
      location: this.location,
      flags: this.#flags,
      predicate: this.predicate,
      conditions: this.conditions,
      elseClause: this.elseClause,
      caseKeywordLoc: this.caseKeywordLoc,
      endKeywordLoc: this.endKeywordLoc,
    };
  }
}

/**
 * Represents the use of a case statement.
 *
 *     case true
 *     when false
 *     end
 *     ^^^^^^^^^^
 */
export class CaseNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Node | null
   */
  predicate;

  /**
   * @type Node[]
   */
  conditions;

  /**
   * @type ElseNode | null
   */
  elseClause;

  /**
   * @type Location
   */
  caseKeywordLoc;

  /**
   * @type Location
   */
  endKeywordLoc;

  /**
   * Construct a new CaseNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Node | null} predicate
   * @param {Node[]} conditions
   * @param {ElseNode | null} elseClause
   * @param {Location} caseKeywordLoc
   * @param {Location} endKeywordLoc
   */
  constructor(nodeID, location, flags, predicate, conditions, elseClause, caseKeywordLoc, endKeywordLoc) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.predicate = predicate;
    this.conditions = conditions;
    this.elseClause = elseClause;
    this.caseKeywordLoc = caseKeywordLoc;
    this.endKeywordLoc = endKeywordLoc;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitCaseNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.predicate, ...this.conditions, this.elseClause]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    const compact = [];

    if (this.predicate) {
      compact.push(this.predicate);
    }
    compact.concat(this.conditions);
    if (this.elseClause) {
      compact.push(this.elseClause);
    }

    return compact;
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "CaseNode",
      location: this.location,
      flags: this.#flags,
      predicate: this.predicate,
      conditions: this.conditions,
      elseClause: this.elseClause,
      caseKeywordLoc: this.caseKeywordLoc,
      endKeywordLoc: this.endKeywordLoc,
    };
  }
}

/**
 * Represents a class declaration involving the `class` keyword.
 *
 *     class Foo end
 *     ^^^^^^^^^^^^^
 */
export class ClassNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type string[]
   */
  locals;

  /**
   * @type Location
   */
  classKeywordLoc;

  /**
   * @type Node
   */
  constantPath;

  /**
   * @type Location | null
   */
  inheritanceOperatorLoc;

  /**
   * @type Node | null
   */
  superclass;

  /**
   * @type Node | null
   */
  body;

  /**
   * @type Location
   */
  endKeywordLoc;

  /**
   * @type string
   */
  name;

  /**
   * Construct a new ClassNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {string[]} locals
   * @param {Location} classKeywordLoc
   * @param {Node} constantPath
   * @param {Location | null} inheritanceOperatorLoc
   * @param {Node | null} superclass
   * @param {Node | null} body
   * @param {Location} endKeywordLoc
   * @param {string} name
   */
  constructor(nodeID, location, flags, locals, classKeywordLoc, constantPath, inheritanceOperatorLoc, superclass, body, endKeywordLoc, name) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.locals = locals;
    this.classKeywordLoc = classKeywordLoc;
    this.constantPath = constantPath;
    this.inheritanceOperatorLoc = inheritanceOperatorLoc;
    this.superclass = superclass;
    this.body = body;
    this.endKeywordLoc = endKeywordLoc;
    this.name = name;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitClassNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.constantPath, this.superclass, this.body]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    const compact = [];

    compact.push(this.constantPath);

    if (this.superclass) {
      compact.push(this.superclass);
    }
    if (this.body) {
      compact.push(this.body);
    }

    return compact;
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "ClassNode",
      location: this.location,
      flags: this.#flags,
      locals: this.locals,
      classKeywordLoc: this.classKeywordLoc,
      constantPath: this.constantPath,
      inheritanceOperatorLoc: this.inheritanceOperatorLoc,
      superclass: this.superclass,
      body: this.body,
      endKeywordLoc: this.endKeywordLoc,
      name: this.name,
    };
  }
}

/**
 * Represents the use of the `&&=` operator for assignment to a class variable.
 *
 *     @@target &&= value
 *     ^^^^^^^^^^^^^^^^^^
 */
export class ClassVariableAndWriteNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type string
   */
  name;

  /**
   * @type Location
   */
  nameLoc;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type Node
   */
  value;

  /**
   * Construct a new ClassVariableAndWriteNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {string} name
   * @param {Location} nameLoc
   * @param {Location} operatorLoc
   * @param {Node} value
   */
  constructor(nodeID, location, flags, name, nameLoc, operatorLoc, value) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.name = name;
    this.nameLoc = nameLoc;
    this.operatorLoc = operatorLoc;
    this.value = value;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitClassVariableAndWriteNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.value]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [this.value];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "ClassVariableAndWriteNode",
      location: this.location,
      flags: this.#flags,
      name: this.name,
      nameLoc: this.nameLoc,
      operatorLoc: this.operatorLoc,
      value: this.value,
    };
  }
}

/**
 * Represents assigning to a class variable using an operator that isn't `=`.
 *
 *     @@target += value
 *     ^^^^^^^^^^^^^^^^^
 */
export class ClassVariableOperatorWriteNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type string
   */
  name;

  /**
   * @type Location
   */
  nameLoc;

  /**
   * @type Location
   */
  binaryOperatorLoc;

  /**
   * @type Node
   */
  value;

  /**
   * @type string
   */
  binaryOperator;

  /**
   * Construct a new ClassVariableOperatorWriteNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {string} name
   * @param {Location} nameLoc
   * @param {Location} binaryOperatorLoc
   * @param {Node} value
   * @param {string} binaryOperator
   */
  constructor(nodeID, location, flags, name, nameLoc, binaryOperatorLoc, value, binaryOperator) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.name = name;
    this.nameLoc = nameLoc;
    this.binaryOperatorLoc = binaryOperatorLoc;
    this.value = value;
    this.binaryOperator = binaryOperator;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitClassVariableOperatorWriteNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.value]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [this.value];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "ClassVariableOperatorWriteNode",
      location: this.location,
      flags: this.#flags,
      name: this.name,
      nameLoc: this.nameLoc,
      binaryOperatorLoc: this.binaryOperatorLoc,
      value: this.value,
      binaryOperator: this.binaryOperator,
    };
  }
}

/**
 * Represents the use of the `||=` operator for assignment to a class variable.
 *
 *     @@target ||= value
 *     ^^^^^^^^^^^^^^^^^^
 */
export class ClassVariableOrWriteNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type string
   */
  name;

  /**
   * @type Location
   */
  nameLoc;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type Node
   */
  value;

  /**
   * Construct a new ClassVariableOrWriteNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {string} name
   * @param {Location} nameLoc
   * @param {Location} operatorLoc
   * @param {Node} value
   */
  constructor(nodeID, location, flags, name, nameLoc, operatorLoc, value) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.name = name;
    this.nameLoc = nameLoc;
    this.operatorLoc = operatorLoc;
    this.value = value;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitClassVariableOrWriteNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.value]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [this.value];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "ClassVariableOrWriteNode",
      location: this.location,
      flags: this.#flags,
      name: this.name,
      nameLoc: this.nameLoc,
      operatorLoc: this.operatorLoc,
      value: this.value,
    };
  }
}

/**
 * Represents referencing a class variable.
 *
 *     @@foo
 *     ^^^^^
 */
export class ClassVariableReadNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type string
   */
  name;

  /**
   * Construct a new ClassVariableReadNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {string} name
   */
  constructor(nodeID, location, flags, name) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.name = name;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitClassVariableReadNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return []
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "ClassVariableReadNode",
      location: this.location,
      flags: this.#flags,
      name: this.name,
    };
  }
}

/**
 * Represents writing to a class variable in a context that doesn't have an explicit value.
 *
 *     @@foo, @@bar = baz
 *     ^^^^^  ^^^^^
 */
export class ClassVariableTargetNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type string
   */
  name;

  /**
   * Construct a new ClassVariableTargetNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {string} name
   */
  constructor(nodeID, location, flags, name) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.name = name;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitClassVariableTargetNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return []
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "ClassVariableTargetNode",
      location: this.location,
      flags: this.#flags,
      name: this.name,
    };
  }
}

/**
 * Represents writing to a class variable.
 *
 *     @@foo = 1
 *     ^^^^^^^^^
 */
export class ClassVariableWriteNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type string
   */
  name;

  /**
   * @type Location
   */
  nameLoc;

  /**
   * @type Node
   */
  value;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * Construct a new ClassVariableWriteNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {string} name
   * @param {Location} nameLoc
   * @param {Node} value
   * @param {Location} operatorLoc
   */
  constructor(nodeID, location, flags, name, nameLoc, value, operatorLoc) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.name = name;
    this.nameLoc = nameLoc;
    this.value = value;
    this.operatorLoc = operatorLoc;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitClassVariableWriteNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.value]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [this.value];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "ClassVariableWriteNode",
      location: this.location,
      flags: this.#flags,
      name: this.name,
      nameLoc: this.nameLoc,
      value: this.value,
      operatorLoc: this.operatorLoc,
    };
  }
}

/**
 * Represents the use of the `&&=` operator for assignment to a constant.
 *
 *     Target &&= value
 *     ^^^^^^^^^^^^^^^^
 */
export class ConstantAndWriteNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type string
   */
  name;

  /**
   * @type Location
   */
  nameLoc;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type Node
   */
  value;

  /**
   * Construct a new ConstantAndWriteNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {string} name
   * @param {Location} nameLoc
   * @param {Location} operatorLoc
   * @param {Node} value
   */
  constructor(nodeID, location, flags, name, nameLoc, operatorLoc, value) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.name = name;
    this.nameLoc = nameLoc;
    this.operatorLoc = operatorLoc;
    this.value = value;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitConstantAndWriteNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.value]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [this.value];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "ConstantAndWriteNode",
      location: this.location,
      flags: this.#flags,
      name: this.name,
      nameLoc: this.nameLoc,
      operatorLoc: this.operatorLoc,
      value: this.value,
    };
  }
}

/**
 * Represents assigning to a constant using an operator that isn't `=`.
 *
 *     Target += value
 *     ^^^^^^^^^^^^^^^
 */
export class ConstantOperatorWriteNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type string
   */
  name;

  /**
   * @type Location
   */
  nameLoc;

  /**
   * @type Location
   */
  binaryOperatorLoc;

  /**
   * @type Node
   */
  value;

  /**
   * @type string
   */
  binaryOperator;

  /**
   * Construct a new ConstantOperatorWriteNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {string} name
   * @param {Location} nameLoc
   * @param {Location} binaryOperatorLoc
   * @param {Node} value
   * @param {string} binaryOperator
   */
  constructor(nodeID, location, flags, name, nameLoc, binaryOperatorLoc, value, binaryOperator) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.name = name;
    this.nameLoc = nameLoc;
    this.binaryOperatorLoc = binaryOperatorLoc;
    this.value = value;
    this.binaryOperator = binaryOperator;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitConstantOperatorWriteNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.value]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [this.value];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "ConstantOperatorWriteNode",
      location: this.location,
      flags: this.#flags,
      name: this.name,
      nameLoc: this.nameLoc,
      binaryOperatorLoc: this.binaryOperatorLoc,
      value: this.value,
      binaryOperator: this.binaryOperator,
    };
  }
}

/**
 * Represents the use of the `||=` operator for assignment to a constant.
 *
 *     Target ||= value
 *     ^^^^^^^^^^^^^^^^
 */
export class ConstantOrWriteNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type string
   */
  name;

  /**
   * @type Location
   */
  nameLoc;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type Node
   */
  value;

  /**
   * Construct a new ConstantOrWriteNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {string} name
   * @param {Location} nameLoc
   * @param {Location} operatorLoc
   * @param {Node} value
   */
  constructor(nodeID, location, flags, name, nameLoc, operatorLoc, value) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.name = name;
    this.nameLoc = nameLoc;
    this.operatorLoc = operatorLoc;
    this.value = value;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitConstantOrWriteNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.value]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [this.value];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "ConstantOrWriteNode",
      location: this.location,
      flags: this.#flags,
      name: this.name,
      nameLoc: this.nameLoc,
      operatorLoc: this.operatorLoc,
      value: this.value,
    };
  }
}

/**
 * Represents the use of the `&&=` operator for assignment to a constant path.
 *
 *     Parent::Child &&= value
 *     ^^^^^^^^^^^^^^^^^^^^^^^
 */
export class ConstantPathAndWriteNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type ConstantPathNode
   */
  target;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type Node
   */
  value;

  /**
   * Construct a new ConstantPathAndWriteNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {ConstantPathNode} target
   * @param {Location} operatorLoc
   * @param {Node} value
   */
  constructor(nodeID, location, flags, target, operatorLoc, value) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.target = target;
    this.operatorLoc = operatorLoc;
    this.value = value;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitConstantPathAndWriteNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.target, this.value]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [this.target, this.value];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "ConstantPathAndWriteNode",
      location: this.location,
      flags: this.#flags,
      target: this.target,
      operatorLoc: this.operatorLoc,
      value: this.value,
    };
  }
}

/**
 * Represents accessing a constant through a path of `::` operators.
 *
 *     Foo::Bar
 *     ^^^^^^^^
 */
export class ConstantPathNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Node | null
   */
  parent;

  /**
   * @type string | null
   */
  name;

  /**
   * @type Location
   */
  delimiterLoc;

  /**
   * @type Location
   */
  nameLoc;

  /**
   * Construct a new ConstantPathNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Node | null} parent
   * @param {string | null} name
   * @param {Location} delimiterLoc
   * @param {Location} nameLoc
   */
  constructor(nodeID, location, flags, parent, name, delimiterLoc, nameLoc) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.parent = parent;
    this.name = name;
    this.delimiterLoc = delimiterLoc;
    this.nameLoc = nameLoc;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitConstantPathNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.parent]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    const compact = [];

    if (this.parent) {
      compact.push(this.parent);
    }

    return compact;
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "ConstantPathNode",
      location: this.location,
      flags: this.#flags,
      parent: this.parent,
      name: this.name,
      delimiterLoc: this.delimiterLoc,
      nameLoc: this.nameLoc,
    };
  }
}

/**
 * Represents assigning to a constant path using an operator that isn't `=`.
 *
 *     Parent::Child += value
 *     ^^^^^^^^^^^^^^^^^^^^^^
 */
export class ConstantPathOperatorWriteNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type ConstantPathNode
   */
  target;

  /**
   * @type Location
   */
  binaryOperatorLoc;

  /**
   * @type Node
   */
  value;

  /**
   * @type string
   */
  binaryOperator;

  /**
   * Construct a new ConstantPathOperatorWriteNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {ConstantPathNode} target
   * @param {Location} binaryOperatorLoc
   * @param {Node} value
   * @param {string} binaryOperator
   */
  constructor(nodeID, location, flags, target, binaryOperatorLoc, value, binaryOperator) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.target = target;
    this.binaryOperatorLoc = binaryOperatorLoc;
    this.value = value;
    this.binaryOperator = binaryOperator;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitConstantPathOperatorWriteNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.target, this.value]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [this.target, this.value];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "ConstantPathOperatorWriteNode",
      location: this.location,
      flags: this.#flags,
      target: this.target,
      binaryOperatorLoc: this.binaryOperatorLoc,
      value: this.value,
      binaryOperator: this.binaryOperator,
    };
  }
}

/**
 * Represents the use of the `||=` operator for assignment to a constant path.
 *
 *     Parent::Child ||= value
 *     ^^^^^^^^^^^^^^^^^^^^^^^
 */
export class ConstantPathOrWriteNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type ConstantPathNode
   */
  target;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type Node
   */
  value;

  /**
   * Construct a new ConstantPathOrWriteNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {ConstantPathNode} target
   * @param {Location} operatorLoc
   * @param {Node} value
   */
  constructor(nodeID, location, flags, target, operatorLoc, value) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.target = target;
    this.operatorLoc = operatorLoc;
    this.value = value;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitConstantPathOrWriteNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.target, this.value]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [this.target, this.value];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "ConstantPathOrWriteNode",
      location: this.location,
      flags: this.#flags,
      target: this.target,
      operatorLoc: this.operatorLoc,
      value: this.value,
    };
  }
}

/**
 * Represents writing to a constant path in a context that doesn't have an explicit value.
 *
 *     Foo::Foo, Bar::Bar = baz
 *     ^^^^^^^^  ^^^^^^^^
 */
export class ConstantPathTargetNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Node | null
   */
  parent;

  /**
   * @type string | null
   */
  name;

  /**
   * @type Location
   */
  delimiterLoc;

  /**
   * @type Location
   */
  nameLoc;

  /**
   * Construct a new ConstantPathTargetNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Node | null} parent
   * @param {string | null} name
   * @param {Location} delimiterLoc
   * @param {Location} nameLoc
   */
  constructor(nodeID, location, flags, parent, name, delimiterLoc, nameLoc) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.parent = parent;
    this.name = name;
    this.delimiterLoc = delimiterLoc;
    this.nameLoc = nameLoc;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitConstantPathTargetNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.parent]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    const compact = [];

    if (this.parent) {
      compact.push(this.parent);
    }

    return compact;
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "ConstantPathTargetNode",
      location: this.location,
      flags: this.#flags,
      parent: this.parent,
      name: this.name,
      delimiterLoc: this.delimiterLoc,
      nameLoc: this.nameLoc,
    };
  }
}

/**
 * Represents writing to a constant path.
 *
 *     ::Foo = 1
 *     ^^^^^^^^^
 *
 *     Foo::Bar = 1
 *     ^^^^^^^^^^^^
 *
 *     ::Foo::Bar = 1
 *     ^^^^^^^^^^^^^^
 */
export class ConstantPathWriteNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type ConstantPathNode
   */
  target;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type Node
   */
  value;

  /**
   * Construct a new ConstantPathWriteNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {ConstantPathNode} target
   * @param {Location} operatorLoc
   * @param {Node} value
   */
  constructor(nodeID, location, flags, target, operatorLoc, value) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.target = target;
    this.operatorLoc = operatorLoc;
    this.value = value;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitConstantPathWriteNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.target, this.value]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [this.target, this.value];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "ConstantPathWriteNode",
      location: this.location,
      flags: this.#flags,
      target: this.target,
      operatorLoc: this.operatorLoc,
      value: this.value,
    };
  }
}

/**
 * Represents referencing a constant.
 *
 *     Foo
 *     ^^^
 */
export class ConstantReadNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type string
   */
  name;

  /**
   * Construct a new ConstantReadNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {string} name
   */
  constructor(nodeID, location, flags, name) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.name = name;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitConstantReadNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return []
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "ConstantReadNode",
      location: this.location,
      flags: this.#flags,
      name: this.name,
    };
  }
}

/**
 * Represents writing to a constant in a context that doesn't have an explicit value.
 *
 *     Foo, Bar = baz
 *     ^^^  ^^^
 */
export class ConstantTargetNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type string
   */
  name;

  /**
   * Construct a new ConstantTargetNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {string} name
   */
  constructor(nodeID, location, flags, name) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.name = name;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitConstantTargetNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return []
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "ConstantTargetNode",
      location: this.location,
      flags: this.#flags,
      name: this.name,
    };
  }
}

/**
 * Represents writing to a constant.
 *
 *     Foo = 1
 *     ^^^^^^^
 */
export class ConstantWriteNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type string
   */
  name;

  /**
   * @type Location
   */
  nameLoc;

  /**
   * @type Node
   */
  value;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * Construct a new ConstantWriteNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {string} name
   * @param {Location} nameLoc
   * @param {Node} value
   * @param {Location} operatorLoc
   */
  constructor(nodeID, location, flags, name, nameLoc, value, operatorLoc) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.name = name;
    this.nameLoc = nameLoc;
    this.value = value;
    this.operatorLoc = operatorLoc;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitConstantWriteNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.value]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [this.value];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "ConstantWriteNode",
      location: this.location,
      flags: this.#flags,
      name: this.name,
      nameLoc: this.nameLoc,
      value: this.value,
      operatorLoc: this.operatorLoc,
    };
  }
}

/**
 * Represents a method definition.
 *
 *     def method
 *     end
 *     ^^^^^^^^^^
 */
export class DefNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type string
   */
  name;

  /**
   * @type Location
   */
  nameLoc;

  /**
   * @type Node | null
   */
  receiver;

  /**
   * @type ParametersNode | null
   */
  parameters;

  /**
   * @type Node | null
   */
  body;

  /**
   * @type string[]
   */
  locals;

  /**
   * @type Location
   */
  defKeywordLoc;

  /**
   * @type Location | null
   */
  operatorLoc;

  /**
   * @type Location | null
   */
  lparenLoc;

  /**
   * @type Location | null
   */
  rparenLoc;

  /**
   * @type Location | null
   */
  equalLoc;

  /**
   * @type Location | null
   */
  endKeywordLoc;

  /**
   * Construct a new DefNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {string} name
   * @param {Location} nameLoc
   * @param {Node | null} receiver
   * @param {ParametersNode | null} parameters
   * @param {Node | null} body
   * @param {string[]} locals
   * @param {Location} defKeywordLoc
   * @param {Location | null} operatorLoc
   * @param {Location | null} lparenLoc
   * @param {Location | null} rparenLoc
   * @param {Location | null} equalLoc
   * @param {Location | null} endKeywordLoc
   */
  constructor(nodeID, location, flags, name, nameLoc, receiver, parameters, body, locals, defKeywordLoc, operatorLoc, lparenLoc, rparenLoc, equalLoc, endKeywordLoc) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.name = name;
    this.nameLoc = nameLoc;
    this.receiver = receiver;
    this.parameters = parameters;
    this.body = body;
    this.locals = locals;
    this.defKeywordLoc = defKeywordLoc;
    this.operatorLoc = operatorLoc;
    this.lparenLoc = lparenLoc;
    this.rparenLoc = rparenLoc;
    this.equalLoc = equalLoc;
    this.endKeywordLoc = endKeywordLoc;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitDefNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.receiver, this.parameters, this.body]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    const compact = [];

    if (this.receiver) {
      compact.push(this.receiver);
    }
    if (this.parameters) {
      compact.push(this.parameters);
    }
    if (this.body) {
      compact.push(this.body);
    }

    return compact;
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "DefNode",
      location: this.location,
      flags: this.#flags,
      name: this.name,
      nameLoc: this.nameLoc,
      receiver: this.receiver,
      parameters: this.parameters,
      body: this.body,
      locals: this.locals,
      defKeywordLoc: this.defKeywordLoc,
      operatorLoc: this.operatorLoc,
      lparenLoc: this.lparenLoc,
      rparenLoc: this.rparenLoc,
      equalLoc: this.equalLoc,
      endKeywordLoc: this.endKeywordLoc,
    };
  }
}

/**
 * Represents the use of the `defined?` keyword.
 *
 *     defined?(a)
 *     ^^^^^^^^^^^
 */
export class DefinedNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Location | null
   */
  lparenLoc;

  /**
   * @type Node
   */
  value;

  /**
   * @type Location | null
   */
  rparenLoc;

  /**
   * @type Location
   */
  keywordLoc;

  /**
   * Construct a new DefinedNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Location | null} lparenLoc
   * @param {Node} value
   * @param {Location | null} rparenLoc
   * @param {Location} keywordLoc
   */
  constructor(nodeID, location, flags, lparenLoc, value, rparenLoc, keywordLoc) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.lparenLoc = lparenLoc;
    this.value = value;
    this.rparenLoc = rparenLoc;
    this.keywordLoc = keywordLoc;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitDefinedNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.value]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [this.value];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "DefinedNode",
      location: this.location,
      flags: this.#flags,
      lparenLoc: this.lparenLoc,
      value: this.value,
      rparenLoc: this.rparenLoc,
      keywordLoc: this.keywordLoc,
    };
  }
}

/**
 * Represents an `else` clause in a `case`, `if`, or `unless` statement.
 *
 *     if a then b else c end
 *                 ^^^^^^^^^^
 */
export class ElseNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Location
   */
  elseKeywordLoc;

  /**
   * @type StatementsNode | null
   */
  statements;

  /**
   * @type Location | null
   */
  endKeywordLoc;

  /**
   * Construct a new ElseNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Location} elseKeywordLoc
   * @param {StatementsNode | null} statements
   * @param {Location | null} endKeywordLoc
   */
  constructor(nodeID, location, flags, elseKeywordLoc, statements, endKeywordLoc) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.elseKeywordLoc = elseKeywordLoc;
    this.statements = statements;
    this.endKeywordLoc = endKeywordLoc;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitElseNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.statements]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    const compact = [];

    if (this.statements) {
      compact.push(this.statements);
    }

    return compact;
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "ElseNode",
      location: this.location,
      flags: this.#flags,
      elseKeywordLoc: this.elseKeywordLoc,
      statements: this.statements,
      endKeywordLoc: this.endKeywordLoc,
    };
  }
}

/**
 * Represents an interpolated set of statements.
 *
 *     "foo #{bar}"
 *          ^^^^^^
 */
export class EmbeddedStatementsNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Location
   */
  openingLoc;

  /**
   * @type StatementsNode | null
   */
  statements;

  /**
   * @type Location
   */
  closingLoc;

  /**
   * Construct a new EmbeddedStatementsNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Location} openingLoc
   * @param {StatementsNode | null} statements
   * @param {Location} closingLoc
   */
  constructor(nodeID, location, flags, openingLoc, statements, closingLoc) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.openingLoc = openingLoc;
    this.statements = statements;
    this.closingLoc = closingLoc;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitEmbeddedStatementsNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.statements]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    const compact = [];

    if (this.statements) {
      compact.push(this.statements);
    }

    return compact;
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "EmbeddedStatementsNode",
      location: this.location,
      flags: this.#flags,
      openingLoc: this.openingLoc,
      statements: this.statements,
      closingLoc: this.closingLoc,
    };
  }
}

/**
 * Represents an interpolated variable.
 *
 *     "foo #@bar"
 *          ^^^^^
 */
export class EmbeddedVariableNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type Node
   */
  variable;

  /**
   * Construct a new EmbeddedVariableNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Location} operatorLoc
   * @param {Node} variable
   */
  constructor(nodeID, location, flags, operatorLoc, variable) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.operatorLoc = operatorLoc;
    this.variable = variable;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitEmbeddedVariableNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.variable]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [this.variable];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "EmbeddedVariableNode",
      location: this.location,
      flags: this.#flags,
      operatorLoc: this.operatorLoc,
      variable: this.variable,
    };
  }
}

/**
 * Represents an `ensure` clause in a `begin` statement.
 *
 *     begin
 *       foo
 *     ensure
 *     ^^^^^^
 *       bar
 *     end
 */
export class EnsureNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Location
   */
  ensureKeywordLoc;

  /**
   * @type StatementsNode | null
   */
  statements;

  /**
   * @type Location
   */
  endKeywordLoc;

  /**
   * Construct a new EnsureNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Location} ensureKeywordLoc
   * @param {StatementsNode | null} statements
   * @param {Location} endKeywordLoc
   */
  constructor(nodeID, location, flags, ensureKeywordLoc, statements, endKeywordLoc) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.ensureKeywordLoc = ensureKeywordLoc;
    this.statements = statements;
    this.endKeywordLoc = endKeywordLoc;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitEnsureNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.statements]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    const compact = [];

    if (this.statements) {
      compact.push(this.statements);
    }

    return compact;
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "EnsureNode",
      location: this.location,
      flags: this.#flags,
      ensureKeywordLoc: this.ensureKeywordLoc,
      statements: this.statements,
      endKeywordLoc: this.endKeywordLoc,
    };
  }
}

/**
 * Represents the use of the literal `false` keyword.
 *
 *     false
 *     ^^^^^
 */
export class FalseNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * Construct a new FalseNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   */
  constructor(nodeID, location, flags) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitFalseNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return []
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "FalseNode",
      location: this.location,
      flags: this.#flags,
    };
  }
}

/**
 * Represents a find pattern in pattern matching.
 *
 *     foo in *bar, baz, *qux
 *            ^^^^^^^^^^^^^^^
 *
 *     foo in [*bar, baz, *qux]
 *            ^^^^^^^^^^^^^^^^^
 *
 *     foo in Foo(*bar, baz, *qux)
 *            ^^^^^^^^^^^^^^^^^^^^
 */
export class FindPatternNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Node | null
   */
  constant;

  /**
   * @type SplatNode
   */
  left;

  /**
   * @type Node[]
   */
  requireds;

  /**
   * @type Node
   */
  right;

  /**
   * @type Location | null
   */
  openingLoc;

  /**
   * @type Location | null
   */
  closingLoc;

  /**
   * Construct a new FindPatternNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Node | null} constant
   * @param {SplatNode} left
   * @param {Node[]} requireds
   * @param {Node} right
   * @param {Location | null} openingLoc
   * @param {Location | null} closingLoc
   */
  constructor(nodeID, location, flags, constant, left, requireds, right, openingLoc, closingLoc) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.constant = constant;
    this.left = left;
    this.requireds = requireds;
    this.right = right;
    this.openingLoc = openingLoc;
    this.closingLoc = closingLoc;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitFindPatternNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.constant, this.left, ...this.requireds, this.right]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    const compact = [];

    if (this.constant) {
      compact.push(this.constant);
    }
    compact.push(this.left);

    compact.concat(this.requireds);
    compact.push(this.right);


    return compact;
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "FindPatternNode",
      location: this.location,
      flags: this.#flags,
      constant: this.constant,
      left: this.left,
      requireds: this.requireds,
      right: this.right,
      openingLoc: this.openingLoc,
      closingLoc: this.closingLoc,
    };
  }
}

/**
 * Represents the use of the `..` or `...` operators to create flip flops.
 *
 *     baz if foo .. bar
 *            ^^^^^^^^^^
 */
export class FlipFlopNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Node | null
   */
  left;

  /**
   * @type Node | null
   */
  right;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * Construct a new FlipFlopNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Node | null} left
   * @param {Node | null} right
   * @param {Location} operatorLoc
   */
  constructor(nodeID, location, flags, left, right, operatorLoc) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.left = left;
    this.right = right;
    this.operatorLoc = operatorLoc;
  }

  /**
   * True if this node has the EXCLUDE_END flag.
   *
   * @returns {boolean}
   */
  isExcludeEnd() {
    return (this.#flags & RangeFlags.EXCLUDE_END) !== 0;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitFlipFlopNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.left, this.right]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    const compact = [];

    if (this.left) {
      compact.push(this.left);
    }
    if (this.right) {
      compact.push(this.right);
    }

    return compact;
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "FlipFlopNode",
      location: this.location,
      flags: this.#flags,
      left: this.left,
      right: this.right,
      operatorLoc: this.operatorLoc,
    };
  }
}

/**
 * Represents a floating point number literal.
 *
 *     1.0
 *     ^^^
 */
export class FloatNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type number
   */
  value;

  /**
   * Construct a new FloatNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {number} value
   */
  constructor(nodeID, location, flags, value) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.value = value;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitFloatNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return []
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "FloatNode",
      location: this.location,
      flags: this.#flags,
      value: this.value,
    };
  }
}

/**
 * Represents the use of the `for` keyword.
 *
 *     for i in a end
 *     ^^^^^^^^^^^^^^
 */
export class ForNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Node
   */
  index;

  /**
   * @type Node
   */
  collection;

  /**
   * @type StatementsNode | null
   */
  statements;

  /**
   * @type Location
   */
  forKeywordLoc;

  /**
   * @type Location
   */
  inKeywordLoc;

  /**
   * @type Location | null
   */
  doKeywordLoc;

  /**
   * @type Location
   */
  endKeywordLoc;

  /**
   * Construct a new ForNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Node} index
   * @param {Node} collection
   * @param {StatementsNode | null} statements
   * @param {Location} forKeywordLoc
   * @param {Location} inKeywordLoc
   * @param {Location | null} doKeywordLoc
   * @param {Location} endKeywordLoc
   */
  constructor(nodeID, location, flags, index, collection, statements, forKeywordLoc, inKeywordLoc, doKeywordLoc, endKeywordLoc) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.index = index;
    this.collection = collection;
    this.statements = statements;
    this.forKeywordLoc = forKeywordLoc;
    this.inKeywordLoc = inKeywordLoc;
    this.doKeywordLoc = doKeywordLoc;
    this.endKeywordLoc = endKeywordLoc;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitForNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.index, this.collection, this.statements]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    const compact = [];

    compact.push(this.index);

    compact.push(this.collection);

    if (this.statements) {
      compact.push(this.statements);
    }

    return compact;
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "ForNode",
      location: this.location,
      flags: this.#flags,
      index: this.index,
      collection: this.collection,
      statements: this.statements,
      forKeywordLoc: this.forKeywordLoc,
      inKeywordLoc: this.inKeywordLoc,
      doKeywordLoc: this.doKeywordLoc,
      endKeywordLoc: this.endKeywordLoc,
    };
  }
}

/**
 * Represents forwarding all arguments to this method to another method.
 *
 *     def foo(...)
 *       bar(...)
 *           ^^^
 *     end
 */
export class ForwardingArgumentsNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * Construct a new ForwardingArgumentsNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   */
  constructor(nodeID, location, flags) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitForwardingArgumentsNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return []
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "ForwardingArgumentsNode",
      location: this.location,
      flags: this.#flags,
    };
  }
}

/**
 * Represents the use of the forwarding parameter in a method, block, or lambda declaration.
 *
 *     def foo(...)
 *             ^^^
 *     end
 */
export class ForwardingParameterNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * Construct a new ForwardingParameterNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   */
  constructor(nodeID, location, flags) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitForwardingParameterNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return []
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "ForwardingParameterNode",
      location: this.location,
      flags: this.#flags,
    };
  }
}

/**
 * Represents the use of the `super` keyword without parentheses or arguments.
 *
 *     super
 *     ^^^^^
 */
export class ForwardingSuperNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type BlockNode | null
   */
  block;

  /**
   * Construct a new ForwardingSuperNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {BlockNode | null} block
   */
  constructor(nodeID, location, flags, block) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.block = block;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitForwardingSuperNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.block]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    const compact = [];

    if (this.block) {
      compact.push(this.block);
    }

    return compact;
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "ForwardingSuperNode",
      location: this.location,
      flags: this.#flags,
      block: this.block,
    };
  }
}

/**
 * Represents the use of the `&&=` operator for assignment to a global variable.
 *
 *     $target &&= value
 *     ^^^^^^^^^^^^^^^^^
 */
export class GlobalVariableAndWriteNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type string
   */
  name;

  /**
   * @type Location
   */
  nameLoc;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type Node
   */
  value;

  /**
   * Construct a new GlobalVariableAndWriteNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {string} name
   * @param {Location} nameLoc
   * @param {Location} operatorLoc
   * @param {Node} value
   */
  constructor(nodeID, location, flags, name, nameLoc, operatorLoc, value) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.name = name;
    this.nameLoc = nameLoc;
    this.operatorLoc = operatorLoc;
    this.value = value;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitGlobalVariableAndWriteNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.value]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [this.value];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "GlobalVariableAndWriteNode",
      location: this.location,
      flags: this.#flags,
      name: this.name,
      nameLoc: this.nameLoc,
      operatorLoc: this.operatorLoc,
      value: this.value,
    };
  }
}

/**
 * Represents assigning to a global variable using an operator that isn't `=`.
 *
 *     $target += value
 *     ^^^^^^^^^^^^^^^^
 */
export class GlobalVariableOperatorWriteNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type string
   */
  name;

  /**
   * @type Location
   */
  nameLoc;

  /**
   * @type Location
   */
  binaryOperatorLoc;

  /**
   * @type Node
   */
  value;

  /**
   * @type string
   */
  binaryOperator;

  /**
   * Construct a new GlobalVariableOperatorWriteNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {string} name
   * @param {Location} nameLoc
   * @param {Location} binaryOperatorLoc
   * @param {Node} value
   * @param {string} binaryOperator
   */
  constructor(nodeID, location, flags, name, nameLoc, binaryOperatorLoc, value, binaryOperator) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.name = name;
    this.nameLoc = nameLoc;
    this.binaryOperatorLoc = binaryOperatorLoc;
    this.value = value;
    this.binaryOperator = binaryOperator;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitGlobalVariableOperatorWriteNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.value]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [this.value];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "GlobalVariableOperatorWriteNode",
      location: this.location,
      flags: this.#flags,
      name: this.name,
      nameLoc: this.nameLoc,
      binaryOperatorLoc: this.binaryOperatorLoc,
      value: this.value,
      binaryOperator: this.binaryOperator,
    };
  }
}

/**
 * Represents the use of the `||=` operator for assignment to a global variable.
 *
 *     $target ||= value
 *     ^^^^^^^^^^^^^^^^^
 */
export class GlobalVariableOrWriteNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type string
   */
  name;

  /**
   * @type Location
   */
  nameLoc;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type Node
   */
  value;

  /**
   * Construct a new GlobalVariableOrWriteNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {string} name
   * @param {Location} nameLoc
   * @param {Location} operatorLoc
   * @param {Node} value
   */
  constructor(nodeID, location, flags, name, nameLoc, operatorLoc, value) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.name = name;
    this.nameLoc = nameLoc;
    this.operatorLoc = operatorLoc;
    this.value = value;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitGlobalVariableOrWriteNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.value]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [this.value];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "GlobalVariableOrWriteNode",
      location: this.location,
      flags: this.#flags,
      name: this.name,
      nameLoc: this.nameLoc,
      operatorLoc: this.operatorLoc,
      value: this.value,
    };
  }
}

/**
 * Represents referencing a global variable.
 *
 *     $foo
 *     ^^^^
 */
export class GlobalVariableReadNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type string
   */
  name;

  /**
   * Construct a new GlobalVariableReadNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {string} name
   */
  constructor(nodeID, location, flags, name) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.name = name;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitGlobalVariableReadNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return []
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "GlobalVariableReadNode",
      location: this.location,
      flags: this.#flags,
      name: this.name,
    };
  }
}

/**
 * Represents writing to a global variable in a context that doesn't have an explicit value.
 *
 *     $foo, $bar = baz
 *     ^^^^  ^^^^
 */
export class GlobalVariableTargetNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type string
   */
  name;

  /**
   * Construct a new GlobalVariableTargetNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {string} name
   */
  constructor(nodeID, location, flags, name) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.name = name;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitGlobalVariableTargetNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return []
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "GlobalVariableTargetNode",
      location: this.location,
      flags: this.#flags,
      name: this.name,
    };
  }
}

/**
 * Represents writing to a global variable.
 *
 *     $foo = 1
 *     ^^^^^^^^
 */
export class GlobalVariableWriteNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type string
   */
  name;

  /**
   * @type Location
   */
  nameLoc;

  /**
   * @type Node
   */
  value;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * Construct a new GlobalVariableWriteNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {string} name
   * @param {Location} nameLoc
   * @param {Node} value
   * @param {Location} operatorLoc
   */
  constructor(nodeID, location, flags, name, nameLoc, value, operatorLoc) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.name = name;
    this.nameLoc = nameLoc;
    this.value = value;
    this.operatorLoc = operatorLoc;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitGlobalVariableWriteNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.value]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [this.value];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "GlobalVariableWriteNode",
      location: this.location,
      flags: this.#flags,
      name: this.name,
      nameLoc: this.nameLoc,
      value: this.value,
      operatorLoc: this.operatorLoc,
    };
  }
}

/**
 * Represents a hash literal.
 *
 *     { a => b }
 *     ^^^^^^^^^^
 */
export class HashNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Location
   */
  openingLoc;

  /**
   * @type Node[]
   */
  elements;

  /**
   * @type Location
   */
  closingLoc;

  /**
   * Construct a new HashNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Location} openingLoc
   * @param {Node[]} elements
   * @param {Location} closingLoc
   */
  constructor(nodeID, location, flags, openingLoc, elements, closingLoc) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.openingLoc = openingLoc;
    this.elements = elements;
    this.closingLoc = closingLoc;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitHashNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [...this.elements]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [...this.elements];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "HashNode",
      location: this.location,
      flags: this.#flags,
      openingLoc: this.openingLoc,
      elements: this.elements,
      closingLoc: this.closingLoc,
    };
  }
}

/**
 * Represents a hash pattern in pattern matching.
 *
 *     foo => { a: 1, b: 2 }
 *            ^^^^^^^^^^^^^^
 *
 *     foo => { a: 1, b: 2, **c }
 *            ^^^^^^^^^^^^^^^^^^^
 */
export class HashPatternNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Node | null
   */
  constant;

  /**
   * @type Node[]
   */
  elements;

  /**
   * @type Node | null
   */
  rest;

  /**
   * @type Location | null
   */
  openingLoc;

  /**
   * @type Location | null
   */
  closingLoc;

  /**
   * Construct a new HashPatternNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Node | null} constant
   * @param {Node[]} elements
   * @param {Node | null} rest
   * @param {Location | null} openingLoc
   * @param {Location | null} closingLoc
   */
  constructor(nodeID, location, flags, constant, elements, rest, openingLoc, closingLoc) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.constant = constant;
    this.elements = elements;
    this.rest = rest;
    this.openingLoc = openingLoc;
    this.closingLoc = closingLoc;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitHashPatternNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.constant, ...this.elements, this.rest]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    const compact = [];

    if (this.constant) {
      compact.push(this.constant);
    }
    compact.concat(this.elements);
    if (this.rest) {
      compact.push(this.rest);
    }

    return compact;
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "HashPatternNode",
      location: this.location,
      flags: this.#flags,
      constant: this.constant,
      elements: this.elements,
      rest: this.rest,
      openingLoc: this.openingLoc,
      closingLoc: this.closingLoc,
    };
  }
}

/**
 * Represents the use of the `if` keyword, either in the block form or the modifier form, or a ternary expression.
 *
 *     bar if foo
 *     ^^^^^^^^^^
 *
 *     if foo then bar end
 *     ^^^^^^^^^^^^^^^^^^^
 *
 *     foo ? bar : baz
 *     ^^^^^^^^^^^^^^^
 */
export class IfNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Location | null
   */
  ifKeywordLoc;

  /**
   * @type Node
   */
  predicate;

  /**
   * @type Location | null
   */
  thenKeywordLoc;

  /**
   * @type StatementsNode | null
   */
  statements;

  /**
   * @type Node | null
   */
  subsequent;

  /**
   * @type Location | null
   */
  endKeywordLoc;

  /**
   * Construct a new IfNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Location | null} ifKeywordLoc
   * @param {Node} predicate
   * @param {Location | null} thenKeywordLoc
   * @param {StatementsNode | null} statements
   * @param {Node | null} subsequent
   * @param {Location | null} endKeywordLoc
   */
  constructor(nodeID, location, flags, ifKeywordLoc, predicate, thenKeywordLoc, statements, subsequent, endKeywordLoc) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.ifKeywordLoc = ifKeywordLoc;
    this.predicate = predicate;
    this.thenKeywordLoc = thenKeywordLoc;
    this.statements = statements;
    this.subsequent = subsequent;
    this.endKeywordLoc = endKeywordLoc;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitIfNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.predicate, this.statements, this.subsequent]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    const compact = [];

    compact.push(this.predicate);

    if (this.statements) {
      compact.push(this.statements);
    }
    if (this.subsequent) {
      compact.push(this.subsequent);
    }

    return compact;
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "IfNode",
      location: this.location,
      flags: this.#flags,
      ifKeywordLoc: this.ifKeywordLoc,
      predicate: this.predicate,
      thenKeywordLoc: this.thenKeywordLoc,
      statements: this.statements,
      subsequent: this.subsequent,
      endKeywordLoc: this.endKeywordLoc,
    };
  }
}

/**
 * Represents an imaginary number literal.
 *
 *     1.0i
 *     ^^^^
 */
export class ImaginaryNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Node
   */
  numeric;

  /**
   * Construct a new ImaginaryNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Node} numeric
   */
  constructor(nodeID, location, flags, numeric) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.numeric = numeric;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitImaginaryNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.numeric]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [this.numeric];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "ImaginaryNode",
      location: this.location,
      flags: this.#flags,
      numeric: this.numeric,
    };
  }
}

/**
 * Represents a node that is implicitly being added to the tree but doesn't correspond directly to a node in the source.
 *
 *     { foo: }
 *       ^^^^
 *
 *     { Foo: }
 *       ^^^^
 *
 *     foo in { bar: }
 *              ^^^^
 */
export class ImplicitNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Node
   */
  value;

  /**
   * Construct a new ImplicitNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Node} value
   */
  constructor(nodeID, location, flags, value) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.value = value;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitImplicitNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.value]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [this.value];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "ImplicitNode",
      location: this.location,
      flags: this.#flags,
      value: this.value,
    };
  }
}

/**
 * Represents using a trailing comma to indicate an implicit rest parameter.
 *
 *     foo { |bar,| }
 *               ^
 *
 *     foo in [bar,]
 *                ^
 *
 *     for foo, in bar do end
 *            ^
 *
 *     foo, = bar
 *        ^
 */
export class ImplicitRestNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * Construct a new ImplicitRestNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   */
  constructor(nodeID, location, flags) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitImplicitRestNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return []
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "ImplicitRestNode",
      location: this.location,
      flags: this.#flags,
    };
  }
}

/**
 * Represents the use of the `in` keyword in a case statement.
 *
 *     case a; in b then c end
 *             ^^^^^^^^^^^
 */
export class InNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Node
   */
  pattern;

  /**
   * @type StatementsNode | null
   */
  statements;

  /**
   * @type Location
   */
  inLoc;

  /**
   * @type Location | null
   */
  thenLoc;

  /**
   * Construct a new InNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Node} pattern
   * @param {StatementsNode | null} statements
   * @param {Location} inLoc
   * @param {Location | null} thenLoc
   */
  constructor(nodeID, location, flags, pattern, statements, inLoc, thenLoc) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.pattern = pattern;
    this.statements = statements;
    this.inLoc = inLoc;
    this.thenLoc = thenLoc;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitInNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.pattern, this.statements]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    const compact = [];

    compact.push(this.pattern);

    if (this.statements) {
      compact.push(this.statements);
    }

    return compact;
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "InNode",
      location: this.location,
      flags: this.#flags,
      pattern: this.pattern,
      statements: this.statements,
      inLoc: this.inLoc,
      thenLoc: this.thenLoc,
    };
  }
}

/**
 * Represents the use of the `&&=` operator on a call to the `[]` method.
 *
 *     foo.bar[baz] &&= value
 *     ^^^^^^^^^^^^^^^^^^^^^^
 */
export class IndexAndWriteNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Node | null
   */
  receiver;

  /**
   * @type Location | null
   */
  callOperatorLoc;

  /**
   * @type Location
   */
  openingLoc;

  /**
   * @type ArgumentsNode | null
   */
  arguments_;

  /**
   * @type Location
   */
  closingLoc;

  /**
   * @type BlockArgumentNode | null
   */
  block;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type Node
   */
  value;

  /**
   * Construct a new IndexAndWriteNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Node | null} receiver
   * @param {Location | null} callOperatorLoc
   * @param {Location} openingLoc
   * @param {ArgumentsNode | null} arguments_
   * @param {Location} closingLoc
   * @param {BlockArgumentNode | null} block
   * @param {Location} operatorLoc
   * @param {Node} value
   */
  constructor(nodeID, location, flags, receiver, callOperatorLoc, openingLoc, arguments_, closingLoc, block, operatorLoc, value) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.receiver = receiver;
    this.callOperatorLoc = callOperatorLoc;
    this.openingLoc = openingLoc;
    this.arguments_ = arguments_;
    this.closingLoc = closingLoc;
    this.block = block;
    this.operatorLoc = operatorLoc;
    this.value = value;
  }

  /**
   * True if this node has the SAFE_NAVIGATION flag.
   *
   * @returns {boolean}
   */
  isSafeNavigation() {
    return (this.#flags & CallNodeFlags.SAFE_NAVIGATION) !== 0;
  }

  /**
   * True if this node has the VARIABLE_CALL flag.
   *
   * @returns {boolean}
   */
  isVariableCall() {
    return (this.#flags & CallNodeFlags.VARIABLE_CALL) !== 0;
  }

  /**
   * True if this node has the ATTRIBUTE_WRITE flag.
   *
   * @returns {boolean}
   */
  isAttributeWrite() {
    return (this.#flags & CallNodeFlags.ATTRIBUTE_WRITE) !== 0;
  }

  /**
   * True if this node has the IGNORE_VISIBILITY flag.
   *
   * @returns {boolean}
   */
  isIgnoreVisibility() {
    return (this.#flags & CallNodeFlags.IGNORE_VISIBILITY) !== 0;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitIndexAndWriteNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.receiver, this.arguments_, this.block, this.value]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    const compact = [];

    if (this.receiver) {
      compact.push(this.receiver);
    }
    if (this.arguments_) {
      compact.push(this.arguments_);
    }
    if (this.block) {
      compact.push(this.block);
    }
    compact.push(this.value);


    return compact;
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "IndexAndWriteNode",
      location: this.location,
      flags: this.#flags,
      receiver: this.receiver,
      callOperatorLoc: this.callOperatorLoc,
      openingLoc: this.openingLoc,
      arguments: this.arguments_,
      closingLoc: this.closingLoc,
      block: this.block,
      operatorLoc: this.operatorLoc,
      value: this.value,
    };
  }
}

/**
 * Represents the use of an assignment operator on a call to `[]`.
 *
 *     foo.bar[baz] += value
 *     ^^^^^^^^^^^^^^^^^^^^^
 */
export class IndexOperatorWriteNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Node | null
   */
  receiver;

  /**
   * @type Location | null
   */
  callOperatorLoc;

  /**
   * @type Location
   */
  openingLoc;

  /**
   * @type ArgumentsNode | null
   */
  arguments_;

  /**
   * @type Location
   */
  closingLoc;

  /**
   * @type BlockArgumentNode | null
   */
  block;

  /**
   * @type string
   */
  binaryOperator;

  /**
   * @type Location
   */
  binaryOperatorLoc;

  /**
   * @type Node
   */
  value;

  /**
   * Construct a new IndexOperatorWriteNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Node | null} receiver
   * @param {Location | null} callOperatorLoc
   * @param {Location} openingLoc
   * @param {ArgumentsNode | null} arguments_
   * @param {Location} closingLoc
   * @param {BlockArgumentNode | null} block
   * @param {string} binaryOperator
   * @param {Location} binaryOperatorLoc
   * @param {Node} value
   */
  constructor(nodeID, location, flags, receiver, callOperatorLoc, openingLoc, arguments_, closingLoc, block, binaryOperator, binaryOperatorLoc, value) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.receiver = receiver;
    this.callOperatorLoc = callOperatorLoc;
    this.openingLoc = openingLoc;
    this.arguments_ = arguments_;
    this.closingLoc = closingLoc;
    this.block = block;
    this.binaryOperator = binaryOperator;
    this.binaryOperatorLoc = binaryOperatorLoc;
    this.value = value;
  }

  /**
   * True if this node has the SAFE_NAVIGATION flag.
   *
   * @returns {boolean}
   */
  isSafeNavigation() {
    return (this.#flags & CallNodeFlags.SAFE_NAVIGATION) !== 0;
  }

  /**
   * True if this node has the VARIABLE_CALL flag.
   *
   * @returns {boolean}
   */
  isVariableCall() {
    return (this.#flags & CallNodeFlags.VARIABLE_CALL) !== 0;
  }

  /**
   * True if this node has the ATTRIBUTE_WRITE flag.
   *
   * @returns {boolean}
   */
  isAttributeWrite() {
    return (this.#flags & CallNodeFlags.ATTRIBUTE_WRITE) !== 0;
  }

  /**
   * True if this node has the IGNORE_VISIBILITY flag.
   *
   * @returns {boolean}
   */
  isIgnoreVisibility() {
    return (this.#flags & CallNodeFlags.IGNORE_VISIBILITY) !== 0;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitIndexOperatorWriteNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.receiver, this.arguments_, this.block, this.value]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    const compact = [];

    if (this.receiver) {
      compact.push(this.receiver);
    }
    if (this.arguments_) {
      compact.push(this.arguments_);
    }
    if (this.block) {
      compact.push(this.block);
    }
    compact.push(this.value);


    return compact;
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "IndexOperatorWriteNode",
      location: this.location,
      flags: this.#flags,
      receiver: this.receiver,
      callOperatorLoc: this.callOperatorLoc,
      openingLoc: this.openingLoc,
      arguments: this.arguments_,
      closingLoc: this.closingLoc,
      block: this.block,
      binaryOperator: this.binaryOperator,
      binaryOperatorLoc: this.binaryOperatorLoc,
      value: this.value,
    };
  }
}

/**
 * Represents the use of the `||=` operator on a call to `[]`.
 *
 *     foo.bar[baz] ||= value
 *     ^^^^^^^^^^^^^^^^^^^^^^
 */
export class IndexOrWriteNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Node | null
   */
  receiver;

  /**
   * @type Location | null
   */
  callOperatorLoc;

  /**
   * @type Location
   */
  openingLoc;

  /**
   * @type ArgumentsNode | null
   */
  arguments_;

  /**
   * @type Location
   */
  closingLoc;

  /**
   * @type BlockArgumentNode | null
   */
  block;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type Node
   */
  value;

  /**
   * Construct a new IndexOrWriteNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Node | null} receiver
   * @param {Location | null} callOperatorLoc
   * @param {Location} openingLoc
   * @param {ArgumentsNode | null} arguments_
   * @param {Location} closingLoc
   * @param {BlockArgumentNode | null} block
   * @param {Location} operatorLoc
   * @param {Node} value
   */
  constructor(nodeID, location, flags, receiver, callOperatorLoc, openingLoc, arguments_, closingLoc, block, operatorLoc, value) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.receiver = receiver;
    this.callOperatorLoc = callOperatorLoc;
    this.openingLoc = openingLoc;
    this.arguments_ = arguments_;
    this.closingLoc = closingLoc;
    this.block = block;
    this.operatorLoc = operatorLoc;
    this.value = value;
  }

  /**
   * True if this node has the SAFE_NAVIGATION flag.
   *
   * @returns {boolean}
   */
  isSafeNavigation() {
    return (this.#flags & CallNodeFlags.SAFE_NAVIGATION) !== 0;
  }

  /**
   * True if this node has the VARIABLE_CALL flag.
   *
   * @returns {boolean}
   */
  isVariableCall() {
    return (this.#flags & CallNodeFlags.VARIABLE_CALL) !== 0;
  }

  /**
   * True if this node has the ATTRIBUTE_WRITE flag.
   *
   * @returns {boolean}
   */
  isAttributeWrite() {
    return (this.#flags & CallNodeFlags.ATTRIBUTE_WRITE) !== 0;
  }

  /**
   * True if this node has the IGNORE_VISIBILITY flag.
   *
   * @returns {boolean}
   */
  isIgnoreVisibility() {
    return (this.#flags & CallNodeFlags.IGNORE_VISIBILITY) !== 0;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitIndexOrWriteNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.receiver, this.arguments_, this.block, this.value]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    const compact = [];

    if (this.receiver) {
      compact.push(this.receiver);
    }
    if (this.arguments_) {
      compact.push(this.arguments_);
    }
    if (this.block) {
      compact.push(this.block);
    }
    compact.push(this.value);


    return compact;
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "IndexOrWriteNode",
      location: this.location,
      flags: this.#flags,
      receiver: this.receiver,
      callOperatorLoc: this.callOperatorLoc,
      openingLoc: this.openingLoc,
      arguments: this.arguments_,
      closingLoc: this.closingLoc,
      block: this.block,
      operatorLoc: this.operatorLoc,
      value: this.value,
    };
  }
}

/**
 * Represents assigning to an index.
 *
 *     foo[bar], = 1
 *     ^^^^^^^^
 *
 *     begin
 *     rescue => foo[bar]
 *               ^^^^^^^^
 *     end
 *
 *     for foo[bar] in baz do end
 *         ^^^^^^^^
 */
export class IndexTargetNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Node
   */
  receiver;

  /**
   * @type Location
   */
  openingLoc;

  /**
   * @type ArgumentsNode | null
   */
  arguments_;

  /**
   * @type Location
   */
  closingLoc;

  /**
   * @type BlockArgumentNode | null
   */
  block;

  /**
   * Construct a new IndexTargetNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Node} receiver
   * @param {Location} openingLoc
   * @param {ArgumentsNode | null} arguments_
   * @param {Location} closingLoc
   * @param {BlockArgumentNode | null} block
   */
  constructor(nodeID, location, flags, receiver, openingLoc, arguments_, closingLoc, block) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.receiver = receiver;
    this.openingLoc = openingLoc;
    this.arguments_ = arguments_;
    this.closingLoc = closingLoc;
    this.block = block;
  }

  /**
   * True if this node has the SAFE_NAVIGATION flag.
   *
   * @returns {boolean}
   */
  isSafeNavigation() {
    return (this.#flags & CallNodeFlags.SAFE_NAVIGATION) !== 0;
  }

  /**
   * True if this node has the VARIABLE_CALL flag.
   *
   * @returns {boolean}
   */
  isVariableCall() {
    return (this.#flags & CallNodeFlags.VARIABLE_CALL) !== 0;
  }

  /**
   * True if this node has the ATTRIBUTE_WRITE flag.
   *
   * @returns {boolean}
   */
  isAttributeWrite() {
    return (this.#flags & CallNodeFlags.ATTRIBUTE_WRITE) !== 0;
  }

  /**
   * True if this node has the IGNORE_VISIBILITY flag.
   *
   * @returns {boolean}
   */
  isIgnoreVisibility() {
    return (this.#flags & CallNodeFlags.IGNORE_VISIBILITY) !== 0;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitIndexTargetNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.receiver, this.arguments_, this.block]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    const compact = [];

    compact.push(this.receiver);

    if (this.arguments_) {
      compact.push(this.arguments_);
    }
    if (this.block) {
      compact.push(this.block);
    }

    return compact;
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "IndexTargetNode",
      location: this.location,
      flags: this.#flags,
      receiver: this.receiver,
      openingLoc: this.openingLoc,
      arguments: this.arguments_,
      closingLoc: this.closingLoc,
      block: this.block,
    };
  }
}

/**
 * Represents the use of the `&&=` operator for assignment to an instance variable.
 *
 *     @target &&= value
 *     ^^^^^^^^^^^^^^^^^
 */
export class InstanceVariableAndWriteNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type string
   */
  name;

  /**
   * @type Location
   */
  nameLoc;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type Node
   */
  value;

  /**
   * Construct a new InstanceVariableAndWriteNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {string} name
   * @param {Location} nameLoc
   * @param {Location} operatorLoc
   * @param {Node} value
   */
  constructor(nodeID, location, flags, name, nameLoc, operatorLoc, value) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.name = name;
    this.nameLoc = nameLoc;
    this.operatorLoc = operatorLoc;
    this.value = value;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitInstanceVariableAndWriteNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.value]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [this.value];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "InstanceVariableAndWriteNode",
      location: this.location,
      flags: this.#flags,
      name: this.name,
      nameLoc: this.nameLoc,
      operatorLoc: this.operatorLoc,
      value: this.value,
    };
  }
}

/**
 * Represents assigning to an instance variable using an operator that isn't `=`.
 *
 *     @target += value
 *     ^^^^^^^^^^^^^^^^
 */
export class InstanceVariableOperatorWriteNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type string
   */
  name;

  /**
   * @type Location
   */
  nameLoc;

  /**
   * @type Location
   */
  binaryOperatorLoc;

  /**
   * @type Node
   */
  value;

  /**
   * @type string
   */
  binaryOperator;

  /**
   * Construct a new InstanceVariableOperatorWriteNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {string} name
   * @param {Location} nameLoc
   * @param {Location} binaryOperatorLoc
   * @param {Node} value
   * @param {string} binaryOperator
   */
  constructor(nodeID, location, flags, name, nameLoc, binaryOperatorLoc, value, binaryOperator) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.name = name;
    this.nameLoc = nameLoc;
    this.binaryOperatorLoc = binaryOperatorLoc;
    this.value = value;
    this.binaryOperator = binaryOperator;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitInstanceVariableOperatorWriteNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.value]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [this.value];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "InstanceVariableOperatorWriteNode",
      location: this.location,
      flags: this.#flags,
      name: this.name,
      nameLoc: this.nameLoc,
      binaryOperatorLoc: this.binaryOperatorLoc,
      value: this.value,
      binaryOperator: this.binaryOperator,
    };
  }
}

/**
 * Represents the use of the `||=` operator for assignment to an instance variable.
 *
 *     @target ||= value
 *     ^^^^^^^^^^^^^^^^^
 */
export class InstanceVariableOrWriteNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type string
   */
  name;

  /**
   * @type Location
   */
  nameLoc;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type Node
   */
  value;

  /**
   * Construct a new InstanceVariableOrWriteNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {string} name
   * @param {Location} nameLoc
   * @param {Location} operatorLoc
   * @param {Node} value
   */
  constructor(nodeID, location, flags, name, nameLoc, operatorLoc, value) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.name = name;
    this.nameLoc = nameLoc;
    this.operatorLoc = operatorLoc;
    this.value = value;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitInstanceVariableOrWriteNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.value]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [this.value];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "InstanceVariableOrWriteNode",
      location: this.location,
      flags: this.#flags,
      name: this.name,
      nameLoc: this.nameLoc,
      operatorLoc: this.operatorLoc,
      value: this.value,
    };
  }
}

/**
 * Represents referencing an instance variable.
 *
 *     @foo
 *     ^^^^
 */
export class InstanceVariableReadNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type string
   */
  name;

  /**
   * Construct a new InstanceVariableReadNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {string} name
   */
  constructor(nodeID, location, flags, name) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.name = name;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitInstanceVariableReadNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return []
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "InstanceVariableReadNode",
      location: this.location,
      flags: this.#flags,
      name: this.name,
    };
  }
}

/**
 * Represents writing to an instance variable in a context that doesn't have an explicit value.
 *
 *     @foo, @bar = baz
 *     ^^^^  ^^^^
 */
export class InstanceVariableTargetNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type string
   */
  name;

  /**
   * Construct a new InstanceVariableTargetNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {string} name
   */
  constructor(nodeID, location, flags, name) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.name = name;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitInstanceVariableTargetNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return []
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "InstanceVariableTargetNode",
      location: this.location,
      flags: this.#flags,
      name: this.name,
    };
  }
}

/**
 * Represents writing to an instance variable.
 *
 *     @foo = 1
 *     ^^^^^^^^
 */
export class InstanceVariableWriteNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type string
   */
  name;

  /**
   * @type Location
   */
  nameLoc;

  /**
   * @type Node
   */
  value;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * Construct a new InstanceVariableWriteNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {string} name
   * @param {Location} nameLoc
   * @param {Node} value
   * @param {Location} operatorLoc
   */
  constructor(nodeID, location, flags, name, nameLoc, value, operatorLoc) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.name = name;
    this.nameLoc = nameLoc;
    this.value = value;
    this.operatorLoc = operatorLoc;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitInstanceVariableWriteNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.value]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [this.value];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "InstanceVariableWriteNode",
      location: this.location,
      flags: this.#flags,
      name: this.name,
      nameLoc: this.nameLoc,
      value: this.value,
      operatorLoc: this.operatorLoc,
    };
  }
}

/**
 * Represents an integer number literal.
 *
 *     1
 *     ^
 */
export class IntegerNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type number
   */
  value;

  /**
   * Construct a new IntegerNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {number} value
   */
  constructor(nodeID, location, flags, value) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.value = value;
  }

  /**
   * True if this node has the BINARY flag.
   *
   * @returns {boolean}
   */
  isBinary() {
    return (this.#flags & IntegerBaseFlags.BINARY) !== 0;
  }

  /**
   * True if this node has the DECIMAL flag.
   *
   * @returns {boolean}
   */
  isDecimal() {
    return (this.#flags & IntegerBaseFlags.DECIMAL) !== 0;
  }

  /**
   * True if this node has the OCTAL flag.
   *
   * @returns {boolean}
   */
  isOctal() {
    return (this.#flags & IntegerBaseFlags.OCTAL) !== 0;
  }

  /**
   * True if this node has the HEXADECIMAL flag.
   *
   * @returns {boolean}
   */
  isHexadecimal() {
    return (this.#flags & IntegerBaseFlags.HEXADECIMAL) !== 0;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitIntegerNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return []
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "IntegerNode",
      location: this.location,
      flags: this.#flags,
      value: this.value,
    };
  }
}

/**
 * Represents a regular expression literal that contains interpolation that is being used in the predicate of a conditional to implicitly match against the last line read by an IO object.
 *
 *     if /foo #{bar} baz/ then end
 *        ^^^^^^^^^^^^^^^^
 */
export class InterpolatedMatchLastLineNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Location
   */
  openingLoc;

  /**
   * @type Node[]
   */
  parts;

  /**
   * @type Location
   */
  closingLoc;

  /**
   * Construct a new InterpolatedMatchLastLineNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Location} openingLoc
   * @param {Node[]} parts
   * @param {Location} closingLoc
   */
  constructor(nodeID, location, flags, openingLoc, parts, closingLoc) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.openingLoc = openingLoc;
    this.parts = parts;
    this.closingLoc = closingLoc;
  }

  /**
   * True if this node has the IGNORE_CASE flag.
   *
   * @returns {boolean}
   */
  isIgnoreCase() {
    return (this.#flags & RegularExpressionFlags.IGNORE_CASE) !== 0;
  }

  /**
   * True if this node has the EXTENDED flag.
   *
   * @returns {boolean}
   */
  isExtended() {
    return (this.#flags & RegularExpressionFlags.EXTENDED) !== 0;
  }

  /**
   * True if this node has the MULTI_LINE flag.
   *
   * @returns {boolean}
   */
  isMultiLine() {
    return (this.#flags & RegularExpressionFlags.MULTI_LINE) !== 0;
  }

  /**
   * True if this node has the ONCE flag.
   *
   * @returns {boolean}
   */
  isOnce() {
    return (this.#flags & RegularExpressionFlags.ONCE) !== 0;
  }

  /**
   * True if this node has the EUC_JP flag.
   *
   * @returns {boolean}
   */
  isEucJp() {
    return (this.#flags & RegularExpressionFlags.EUC_JP) !== 0;
  }

  /**
   * True if this node has the ASCII_8BIT flag.
   *
   * @returns {boolean}
   */
  isAscii8bit() {
    return (this.#flags & RegularExpressionFlags.ASCII_8BIT) !== 0;
  }

  /**
   * True if this node has the WINDOWS_31J flag.
   *
   * @returns {boolean}
   */
  isWindows31j() {
    return (this.#flags & RegularExpressionFlags.WINDOWS_31J) !== 0;
  }

  /**
   * True if this node has the UTF_8 flag.
   *
   * @returns {boolean}
   */
  isUtf8() {
    return (this.#flags & RegularExpressionFlags.UTF_8) !== 0;
  }

  /**
   * True if this node has the FORCED_UTF8_ENCODING flag.
   *
   * @returns {boolean}
   */
  isForcedUtf8Encoding() {
    return (this.#flags & RegularExpressionFlags.FORCED_UTF8_ENCODING) !== 0;
  }

  /**
   * True if this node has the FORCED_BINARY_ENCODING flag.
   *
   * @returns {boolean}
   */
  isForcedBinaryEncoding() {
    return (this.#flags & RegularExpressionFlags.FORCED_BINARY_ENCODING) !== 0;
  }

  /**
   * True if this node has the FORCED_US_ASCII_ENCODING flag.
   *
   * @returns {boolean}
   */
  isForcedUsAsciiEncoding() {
    return (this.#flags & RegularExpressionFlags.FORCED_US_ASCII_ENCODING) !== 0;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitInterpolatedMatchLastLineNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [...this.parts]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [...this.parts];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "InterpolatedMatchLastLineNode",
      location: this.location,
      flags: this.#flags,
      openingLoc: this.openingLoc,
      parts: this.parts,
      closingLoc: this.closingLoc,
    };
  }
}

/**
 * Represents a regular expression literal that contains interpolation.
 *
 *     /foo #{bar} baz/
 *     ^^^^^^^^^^^^^^^^
 */
export class InterpolatedRegularExpressionNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Location
   */
  openingLoc;

  /**
   * @type Node[]
   */
  parts;

  /**
   * @type Location
   */
  closingLoc;

  /**
   * Construct a new InterpolatedRegularExpressionNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Location} openingLoc
   * @param {Node[]} parts
   * @param {Location} closingLoc
   */
  constructor(nodeID, location, flags, openingLoc, parts, closingLoc) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.openingLoc = openingLoc;
    this.parts = parts;
    this.closingLoc = closingLoc;
  }

  /**
   * True if this node has the IGNORE_CASE flag.
   *
   * @returns {boolean}
   */
  isIgnoreCase() {
    return (this.#flags & RegularExpressionFlags.IGNORE_CASE) !== 0;
  }

  /**
   * True if this node has the EXTENDED flag.
   *
   * @returns {boolean}
   */
  isExtended() {
    return (this.#flags & RegularExpressionFlags.EXTENDED) !== 0;
  }

  /**
   * True if this node has the MULTI_LINE flag.
   *
   * @returns {boolean}
   */
  isMultiLine() {
    return (this.#flags & RegularExpressionFlags.MULTI_LINE) !== 0;
  }

  /**
   * True if this node has the ONCE flag.
   *
   * @returns {boolean}
   */
  isOnce() {
    return (this.#flags & RegularExpressionFlags.ONCE) !== 0;
  }

  /**
   * True if this node has the EUC_JP flag.
   *
   * @returns {boolean}
   */
  isEucJp() {
    return (this.#flags & RegularExpressionFlags.EUC_JP) !== 0;
  }

  /**
   * True if this node has the ASCII_8BIT flag.
   *
   * @returns {boolean}
   */
  isAscii8bit() {
    return (this.#flags & RegularExpressionFlags.ASCII_8BIT) !== 0;
  }

  /**
   * True if this node has the WINDOWS_31J flag.
   *
   * @returns {boolean}
   */
  isWindows31j() {
    return (this.#flags & RegularExpressionFlags.WINDOWS_31J) !== 0;
  }

  /**
   * True if this node has the UTF_8 flag.
   *
   * @returns {boolean}
   */
  isUtf8() {
    return (this.#flags & RegularExpressionFlags.UTF_8) !== 0;
  }

  /**
   * True if this node has the FORCED_UTF8_ENCODING flag.
   *
   * @returns {boolean}
   */
  isForcedUtf8Encoding() {
    return (this.#flags & RegularExpressionFlags.FORCED_UTF8_ENCODING) !== 0;
  }

  /**
   * True if this node has the FORCED_BINARY_ENCODING flag.
   *
   * @returns {boolean}
   */
  isForcedBinaryEncoding() {
    return (this.#flags & RegularExpressionFlags.FORCED_BINARY_ENCODING) !== 0;
  }

  /**
   * True if this node has the FORCED_US_ASCII_ENCODING flag.
   *
   * @returns {boolean}
   */
  isForcedUsAsciiEncoding() {
    return (this.#flags & RegularExpressionFlags.FORCED_US_ASCII_ENCODING) !== 0;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitInterpolatedRegularExpressionNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [...this.parts]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [...this.parts];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "InterpolatedRegularExpressionNode",
      location: this.location,
      flags: this.#flags,
      openingLoc: this.openingLoc,
      parts: this.parts,
      closingLoc: this.closingLoc,
    };
  }
}

/**
 * Represents a string literal that contains interpolation.
 *
 *     "foo #{bar} baz"
 *     ^^^^^^^^^^^^^^^^
 */
export class InterpolatedStringNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Location | null
   */
  openingLoc;

  /**
   * @type Node[]
   */
  parts;

  /**
   * @type Location | null
   */
  closingLoc;

  /**
   * Construct a new InterpolatedStringNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Location | null} openingLoc
   * @param {Node[]} parts
   * @param {Location | null} closingLoc
   */
  constructor(nodeID, location, flags, openingLoc, parts, closingLoc) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.openingLoc = openingLoc;
    this.parts = parts;
    this.closingLoc = closingLoc;
  }

  /**
   * True if this node has the FROZEN flag.
   *
   * @returns {boolean}
   */
  isFrozen() {
    return (this.#flags & InterpolatedStringNodeFlags.FROZEN) !== 0;
  }

  /**
   * True if this node has the MUTABLE flag.
   *
   * @returns {boolean}
   */
  isMutable() {
    return (this.#flags & InterpolatedStringNodeFlags.MUTABLE) !== 0;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitInterpolatedStringNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [...this.parts]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [...this.parts];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "InterpolatedStringNode",
      location: this.location,
      flags: this.#flags,
      openingLoc: this.openingLoc,
      parts: this.parts,
      closingLoc: this.closingLoc,
    };
  }
}

/**
 * Represents a symbol literal that contains interpolation.
 *
 *     :"foo #{bar} baz"
 *     ^^^^^^^^^^^^^^^^^
 */
export class InterpolatedSymbolNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Location | null
   */
  openingLoc;

  /**
   * @type Node[]
   */
  parts;

  /**
   * @type Location | null
   */
  closingLoc;

  /**
   * Construct a new InterpolatedSymbolNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Location | null} openingLoc
   * @param {Node[]} parts
   * @param {Location | null} closingLoc
   */
  constructor(nodeID, location, flags, openingLoc, parts, closingLoc) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.openingLoc = openingLoc;
    this.parts = parts;
    this.closingLoc = closingLoc;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitInterpolatedSymbolNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [...this.parts]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [...this.parts];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "InterpolatedSymbolNode",
      location: this.location,
      flags: this.#flags,
      openingLoc: this.openingLoc,
      parts: this.parts,
      closingLoc: this.closingLoc,
    };
  }
}

/**
 * Represents an xstring literal that contains interpolation.
 *
 *     `foo #{bar} baz`
 *     ^^^^^^^^^^^^^^^^
 */
export class InterpolatedXStringNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Location
   */
  openingLoc;

  /**
   * @type Node[]
   */
  parts;

  /**
   * @type Location
   */
  closingLoc;

  /**
   * Construct a new InterpolatedXStringNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Location} openingLoc
   * @param {Node[]} parts
   * @param {Location} closingLoc
   */
  constructor(nodeID, location, flags, openingLoc, parts, closingLoc) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.openingLoc = openingLoc;
    this.parts = parts;
    this.closingLoc = closingLoc;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitInterpolatedXStringNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [...this.parts]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [...this.parts];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "InterpolatedXStringNode",
      location: this.location,
      flags: this.#flags,
      openingLoc: this.openingLoc,
      parts: this.parts,
      closingLoc: this.closingLoc,
    };
  }
}

/**
 * Represents reading from the implicit `it` local variable.
 *
 *     -> { it }
 *          ^^
 */
export class ItLocalVariableReadNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * Construct a new ItLocalVariableReadNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   */
  constructor(nodeID, location, flags) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitItLocalVariableReadNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return []
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "ItLocalVariableReadNode",
      location: this.location,
      flags: this.#flags,
    };
  }
}

/**
 * Represents an implicit set of parameters through the use of the `it` keyword within a block or lambda.
 *
 *     -> { it + it }
 *     ^^^^^^^^^^^^^^
 */
export class ItParametersNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * Construct a new ItParametersNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   */
  constructor(nodeID, location, flags) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitItParametersNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return []
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "ItParametersNode",
      location: this.location,
      flags: this.#flags,
    };
  }
}

/**
 * Represents a hash literal without opening and closing braces.
 *
 *     foo(a: b)
 *         ^^^^
 */
export class KeywordHashNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Node[]
   */
  elements;

  /**
   * Construct a new KeywordHashNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Node[]} elements
   */
  constructor(nodeID, location, flags, elements) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.elements = elements;
  }

  /**
   * True if this node has the SYMBOL_KEYS flag.
   *
   * @returns {boolean}
   */
  isSymbolKeys() {
    return (this.#flags & KeywordHashNodeFlags.SYMBOL_KEYS) !== 0;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitKeywordHashNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [...this.elements]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [...this.elements];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "KeywordHashNode",
      location: this.location,
      flags: this.#flags,
      elements: this.elements,
    };
  }
}

/**
 * Represents a keyword rest parameter to a method, block, or lambda definition.
 *
 *     def a(**b)
 *           ^^^
 *     end
 */
export class KeywordRestParameterNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type string | null
   */
  name;

  /**
   * @type Location | null
   */
  nameLoc;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * Construct a new KeywordRestParameterNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {string | null} name
   * @param {Location | null} nameLoc
   * @param {Location} operatorLoc
   */
  constructor(nodeID, location, flags, name, nameLoc, operatorLoc) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.name = name;
    this.nameLoc = nameLoc;
    this.operatorLoc = operatorLoc;
  }

  /**
   * True if this node has the REPEATED_PARAMETER flag.
   *
   * @returns {boolean}
   */
  isRepeatedParameter() {
    return (this.#flags & ParameterFlags.REPEATED_PARAMETER) !== 0;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitKeywordRestParameterNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return []
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "KeywordRestParameterNode",
      location: this.location,
      flags: this.#flags,
      name: this.name,
      nameLoc: this.nameLoc,
      operatorLoc: this.operatorLoc,
    };
  }
}

/**
 * Represents using a lambda literal (not the lambda method call).
 *
 *     ->(value) { value * 2 }
 *     ^^^^^^^^^^^^^^^^^^^^^^^
 */
export class LambdaNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type string[]
   */
  locals;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type Location
   */
  openingLoc;

  /**
   * @type Location
   */
  closingLoc;

  /**
   * @type Node | null
   */
  parameters;

  /**
   * @type Node | null
   */
  body;

  /**
   * Construct a new LambdaNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {string[]} locals
   * @param {Location} operatorLoc
   * @param {Location} openingLoc
   * @param {Location} closingLoc
   * @param {Node | null} parameters
   * @param {Node | null} body
   */
  constructor(nodeID, location, flags, locals, operatorLoc, openingLoc, closingLoc, parameters, body) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.locals = locals;
    this.operatorLoc = operatorLoc;
    this.openingLoc = openingLoc;
    this.closingLoc = closingLoc;
    this.parameters = parameters;
    this.body = body;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitLambdaNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.parameters, this.body]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    const compact = [];

    if (this.parameters) {
      compact.push(this.parameters);
    }
    if (this.body) {
      compact.push(this.body);
    }

    return compact;
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "LambdaNode",
      location: this.location,
      flags: this.#flags,
      locals: this.locals,
      operatorLoc: this.operatorLoc,
      openingLoc: this.openingLoc,
      closingLoc: this.closingLoc,
      parameters: this.parameters,
      body: this.body,
    };
  }
}

/**
 * Represents the use of the `&&=` operator for assignment to a local variable.
 *
 *     target &&= value
 *     ^^^^^^^^^^^^^^^^
 */
export class LocalVariableAndWriteNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Location
   */
  nameLoc;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type Node
   */
  value;

  /**
   * @type string
   */
  name;

  /**
   * @type number
   */
  depth;

  /**
   * Construct a new LocalVariableAndWriteNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Location} nameLoc
   * @param {Location} operatorLoc
   * @param {Node} value
   * @param {string} name
   * @param {number} depth
   */
  constructor(nodeID, location, flags, nameLoc, operatorLoc, value, name, depth) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.nameLoc = nameLoc;
    this.operatorLoc = operatorLoc;
    this.value = value;
    this.name = name;
    this.depth = depth;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitLocalVariableAndWriteNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.value]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [this.value];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "LocalVariableAndWriteNode",
      location: this.location,
      flags: this.#flags,
      nameLoc: this.nameLoc,
      operatorLoc: this.operatorLoc,
      value: this.value,
      name: this.name,
      depth: this.depth,
    };
  }
}

/**
 * Represents assigning to a local variable using an operator that isn't `=`.
 *
 *     target += value
 *     ^^^^^^^^^^^^^^^
 */
export class LocalVariableOperatorWriteNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Location
   */
  nameLoc;

  /**
   * @type Location
   */
  binaryOperatorLoc;

  /**
   * @type Node
   */
  value;

  /**
   * @type string
   */
  name;

  /**
   * @type string
   */
  binaryOperator;

  /**
   * @type number
   */
  depth;

  /**
   * Construct a new LocalVariableOperatorWriteNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Location} nameLoc
   * @param {Location} binaryOperatorLoc
   * @param {Node} value
   * @param {string} name
   * @param {string} binaryOperator
   * @param {number} depth
   */
  constructor(nodeID, location, flags, nameLoc, binaryOperatorLoc, value, name, binaryOperator, depth) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.nameLoc = nameLoc;
    this.binaryOperatorLoc = binaryOperatorLoc;
    this.value = value;
    this.name = name;
    this.binaryOperator = binaryOperator;
    this.depth = depth;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitLocalVariableOperatorWriteNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.value]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [this.value];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "LocalVariableOperatorWriteNode",
      location: this.location,
      flags: this.#flags,
      nameLoc: this.nameLoc,
      binaryOperatorLoc: this.binaryOperatorLoc,
      value: this.value,
      name: this.name,
      binaryOperator: this.binaryOperator,
      depth: this.depth,
    };
  }
}

/**
 * Represents the use of the `||=` operator for assignment to a local variable.
 *
 *     target ||= value
 *     ^^^^^^^^^^^^^^^^
 */
export class LocalVariableOrWriteNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Location
   */
  nameLoc;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type Node
   */
  value;

  /**
   * @type string
   */
  name;

  /**
   * @type number
   */
  depth;

  /**
   * Construct a new LocalVariableOrWriteNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Location} nameLoc
   * @param {Location} operatorLoc
   * @param {Node} value
   * @param {string} name
   * @param {number} depth
   */
  constructor(nodeID, location, flags, nameLoc, operatorLoc, value, name, depth) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.nameLoc = nameLoc;
    this.operatorLoc = operatorLoc;
    this.value = value;
    this.name = name;
    this.depth = depth;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitLocalVariableOrWriteNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.value]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [this.value];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "LocalVariableOrWriteNode",
      location: this.location,
      flags: this.#flags,
      nameLoc: this.nameLoc,
      operatorLoc: this.operatorLoc,
      value: this.value,
      name: this.name,
      depth: this.depth,
    };
  }
}

/**
 * Represents reading a local variable. Note that this requires that a local variable of the same name has already been written to in the same scope, otherwise it is parsed as a method call.
 *
 *     foo
 *     ^^^
 */
export class LocalVariableReadNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type string
   */
  name;

  /**
   * @type number
   */
  depth;

  /**
   * Construct a new LocalVariableReadNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {string} name
   * @param {number} depth
   */
  constructor(nodeID, location, flags, name, depth) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.name = name;
    this.depth = depth;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitLocalVariableReadNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return []
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "LocalVariableReadNode",
      location: this.location,
      flags: this.#flags,
      name: this.name,
      depth: this.depth,
    };
  }
}

/**
 * Represents writing to a local variable in a context that doesn't have an explicit value.
 *
 *     foo, bar = baz
 *     ^^^  ^^^
 */
export class LocalVariableTargetNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type string
   */
  name;

  /**
   * @type number
   */
  depth;

  /**
   * Construct a new LocalVariableTargetNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {string} name
   * @param {number} depth
   */
  constructor(nodeID, location, flags, name, depth) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.name = name;
    this.depth = depth;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitLocalVariableTargetNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return []
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "LocalVariableTargetNode",
      location: this.location,
      flags: this.#flags,
      name: this.name,
      depth: this.depth,
    };
  }
}

/**
 * Represents writing to a local variable.
 *
 *     foo = 1
 *     ^^^^^^^
 */
export class LocalVariableWriteNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type string
   */
  name;

  /**
   * @type number
   */
  depth;

  /**
   * @type Location
   */
  nameLoc;

  /**
   * @type Node
   */
  value;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * Construct a new LocalVariableWriteNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {string} name
   * @param {number} depth
   * @param {Location} nameLoc
   * @param {Node} value
   * @param {Location} operatorLoc
   */
  constructor(nodeID, location, flags, name, depth, nameLoc, value, operatorLoc) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.name = name;
    this.depth = depth;
    this.nameLoc = nameLoc;
    this.value = value;
    this.operatorLoc = operatorLoc;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitLocalVariableWriteNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.value]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [this.value];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "LocalVariableWriteNode",
      location: this.location,
      flags: this.#flags,
      name: this.name,
      depth: this.depth,
      nameLoc: this.nameLoc,
      value: this.value,
      operatorLoc: this.operatorLoc,
    };
  }
}

/**
 * Represents a regular expression literal used in the predicate of a conditional to implicitly match against the last line read by an IO object.
 *
 *     if /foo/i then end
 *        ^^^^^^
 */
export class MatchLastLineNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Location
   */
  openingLoc;

  /**
   * @type Location
   */
  contentLoc;

  /**
   * @type Location
   */
  closingLoc;

  /**
   * @type RubyString
   */
  unescaped;

  /**
   * Construct a new MatchLastLineNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Location} openingLoc
   * @param {Location} contentLoc
   * @param {Location} closingLoc
   * @param {RubyString} unescaped
   */
  constructor(nodeID, location, flags, openingLoc, contentLoc, closingLoc, unescaped) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.openingLoc = openingLoc;
    this.contentLoc = contentLoc;
    this.closingLoc = closingLoc;
    this.unescaped = unescaped;
  }

  /**
   * True if this node has the IGNORE_CASE flag.
   *
   * @returns {boolean}
   */
  isIgnoreCase() {
    return (this.#flags & RegularExpressionFlags.IGNORE_CASE) !== 0;
  }

  /**
   * True if this node has the EXTENDED flag.
   *
   * @returns {boolean}
   */
  isExtended() {
    return (this.#flags & RegularExpressionFlags.EXTENDED) !== 0;
  }

  /**
   * True if this node has the MULTI_LINE flag.
   *
   * @returns {boolean}
   */
  isMultiLine() {
    return (this.#flags & RegularExpressionFlags.MULTI_LINE) !== 0;
  }

  /**
   * True if this node has the ONCE flag.
   *
   * @returns {boolean}
   */
  isOnce() {
    return (this.#flags & RegularExpressionFlags.ONCE) !== 0;
  }

  /**
   * True if this node has the EUC_JP flag.
   *
   * @returns {boolean}
   */
  isEucJp() {
    return (this.#flags & RegularExpressionFlags.EUC_JP) !== 0;
  }

  /**
   * True if this node has the ASCII_8BIT flag.
   *
   * @returns {boolean}
   */
  isAscii8bit() {
    return (this.#flags & RegularExpressionFlags.ASCII_8BIT) !== 0;
  }

  /**
   * True if this node has the WINDOWS_31J flag.
   *
   * @returns {boolean}
   */
  isWindows31j() {
    return (this.#flags & RegularExpressionFlags.WINDOWS_31J) !== 0;
  }

  /**
   * True if this node has the UTF_8 flag.
   *
   * @returns {boolean}
   */
  isUtf8() {
    return (this.#flags & RegularExpressionFlags.UTF_8) !== 0;
  }

  /**
   * True if this node has the FORCED_UTF8_ENCODING flag.
   *
   * @returns {boolean}
   */
  isForcedUtf8Encoding() {
    return (this.#flags & RegularExpressionFlags.FORCED_UTF8_ENCODING) !== 0;
  }

  /**
   * True if this node has the FORCED_BINARY_ENCODING flag.
   *
   * @returns {boolean}
   */
  isForcedBinaryEncoding() {
    return (this.#flags & RegularExpressionFlags.FORCED_BINARY_ENCODING) !== 0;
  }

  /**
   * True if this node has the FORCED_US_ASCII_ENCODING flag.
   *
   * @returns {boolean}
   */
  isForcedUsAsciiEncoding() {
    return (this.#flags & RegularExpressionFlags.FORCED_US_ASCII_ENCODING) !== 0;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitMatchLastLineNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return []
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "MatchLastLineNode",
      location: this.location,
      flags: this.#flags,
      openingLoc: this.openingLoc,
      contentLoc: this.contentLoc,
      closingLoc: this.closingLoc,
      unescaped: this.unescaped,
    };
  }
}

/**
 * Represents the use of the modifier `in` operator.
 *
 *     foo in bar
 *     ^^^^^^^^^^
 */
export class MatchPredicateNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Node
   */
  value;

  /**
   * @type Node
   */
  pattern;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * Construct a new MatchPredicateNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Node} value
   * @param {Node} pattern
   * @param {Location} operatorLoc
   */
  constructor(nodeID, location, flags, value, pattern, operatorLoc) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.value = value;
    this.pattern = pattern;
    this.operatorLoc = operatorLoc;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitMatchPredicateNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.value, this.pattern]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [this.value, this.pattern];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "MatchPredicateNode",
      location: this.location,
      flags: this.#flags,
      value: this.value,
      pattern: this.pattern,
      operatorLoc: this.operatorLoc,
    };
  }
}

/**
 * Represents the use of the `=>` operator.
 *
 *     foo => bar
 *     ^^^^^^^^^^
 */
export class MatchRequiredNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Node
   */
  value;

  /**
   * @type Node
   */
  pattern;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * Construct a new MatchRequiredNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Node} value
   * @param {Node} pattern
   * @param {Location} operatorLoc
   */
  constructor(nodeID, location, flags, value, pattern, operatorLoc) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.value = value;
    this.pattern = pattern;
    this.operatorLoc = operatorLoc;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitMatchRequiredNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.value, this.pattern]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [this.value, this.pattern];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "MatchRequiredNode",
      location: this.location,
      flags: this.#flags,
      value: this.value,
      pattern: this.pattern,
      operatorLoc: this.operatorLoc,
    };
  }
}

/**
 * Represents writing local variables using a regular expression match with named capture groups.
 *
 *     /(?<foo>bar)/ =~ baz
 *     ^^^^^^^^^^^^^^^^^^^^
 */
export class MatchWriteNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type CallNode
   */
  call;

  /**
   * @type Node[]
   */
  targets;

  /**
   * Construct a new MatchWriteNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {CallNode} call
   * @param {Node[]} targets
   */
  constructor(nodeID, location, flags, call, targets) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.call = call;
    this.targets = targets;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitMatchWriteNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.call, ...this.targets]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [this.call, ...this.targets];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "MatchWriteNode",
      location: this.location,
      flags: this.#flags,
      call: this.call,
      targets: this.targets,
    };
  }
}

/**
 * Represents a node that is missing from the source and results in a syntax error.
 */
export class MissingNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * Construct a new MissingNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   */
  constructor(nodeID, location, flags) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitMissingNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return []
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "MissingNode",
      location: this.location,
      flags: this.#flags,
    };
  }
}

/**
 * Represents a module declaration involving the `module` keyword.
 *
 *     module Foo end
 *     ^^^^^^^^^^^^^^
 */
export class ModuleNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type string[]
   */
  locals;

  /**
   * @type Location
   */
  moduleKeywordLoc;

  /**
   * @type Node
   */
  constantPath;

  /**
   * @type Node | null
   */
  body;

  /**
   * @type Location
   */
  endKeywordLoc;

  /**
   * @type string
   */
  name;

  /**
   * Construct a new ModuleNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {string[]} locals
   * @param {Location} moduleKeywordLoc
   * @param {Node} constantPath
   * @param {Node | null} body
   * @param {Location} endKeywordLoc
   * @param {string} name
   */
  constructor(nodeID, location, flags, locals, moduleKeywordLoc, constantPath, body, endKeywordLoc, name) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.locals = locals;
    this.moduleKeywordLoc = moduleKeywordLoc;
    this.constantPath = constantPath;
    this.body = body;
    this.endKeywordLoc = endKeywordLoc;
    this.name = name;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitModuleNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.constantPath, this.body]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    const compact = [];

    compact.push(this.constantPath);

    if (this.body) {
      compact.push(this.body);
    }

    return compact;
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "ModuleNode",
      location: this.location,
      flags: this.#flags,
      locals: this.locals,
      moduleKeywordLoc: this.moduleKeywordLoc,
      constantPath: this.constantPath,
      body: this.body,
      endKeywordLoc: this.endKeywordLoc,
      name: this.name,
    };
  }
}

/**
 * Represents a multi-target expression.
 *
 *     a, (b, c) = 1, 2, 3
 *        ^^^^^^
 *
 * This can be a part of `MultiWriteNode` as above, or the target of a `for` loop
 *
 *     for a, b in [[1, 2], [3, 4]]
 *         ^^^^
 */
export class MultiTargetNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Node[]
   */
  lefts;

  /**
   * @type Node | null
   */
  rest;

  /**
   * @type Node[]
   */
  rights;

  /**
   * @type Location | null
   */
  lparenLoc;

  /**
   * @type Location | null
   */
  rparenLoc;

  /**
   * Construct a new MultiTargetNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Node[]} lefts
   * @param {Node | null} rest
   * @param {Node[]} rights
   * @param {Location | null} lparenLoc
   * @param {Location | null} rparenLoc
   */
  constructor(nodeID, location, flags, lefts, rest, rights, lparenLoc, rparenLoc) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.lefts = lefts;
    this.rest = rest;
    this.rights = rights;
    this.lparenLoc = lparenLoc;
    this.rparenLoc = rparenLoc;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitMultiTargetNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [...this.lefts, this.rest, ...this.rights]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    const compact = [];

    compact.concat(this.lefts);
    if (this.rest) {
      compact.push(this.rest);
    }
    compact.concat(this.rights);

    return compact;
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "MultiTargetNode",
      location: this.location,
      flags: this.#flags,
      lefts: this.lefts,
      rest: this.rest,
      rights: this.rights,
      lparenLoc: this.lparenLoc,
      rparenLoc: this.rparenLoc,
    };
  }
}

/**
 * Represents a write to a multi-target expression.
 *
 *     a, b, c = 1, 2, 3
 *     ^^^^^^^^^^^^^^^^^
 */
export class MultiWriteNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Node[]
   */
  lefts;

  /**
   * @type Node | null
   */
  rest;

  /**
   * @type Node[]
   */
  rights;

  /**
   * @type Location | null
   */
  lparenLoc;

  /**
   * @type Location | null
   */
  rparenLoc;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type Node
   */
  value;

  /**
   * Construct a new MultiWriteNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Node[]} lefts
   * @param {Node | null} rest
   * @param {Node[]} rights
   * @param {Location | null} lparenLoc
   * @param {Location | null} rparenLoc
   * @param {Location} operatorLoc
   * @param {Node} value
   */
  constructor(nodeID, location, flags, lefts, rest, rights, lparenLoc, rparenLoc, operatorLoc, value) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.lefts = lefts;
    this.rest = rest;
    this.rights = rights;
    this.lparenLoc = lparenLoc;
    this.rparenLoc = rparenLoc;
    this.operatorLoc = operatorLoc;
    this.value = value;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitMultiWriteNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [...this.lefts, this.rest, ...this.rights, this.value]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    const compact = [];

    compact.concat(this.lefts);
    if (this.rest) {
      compact.push(this.rest);
    }
    compact.concat(this.rights);
    compact.push(this.value);


    return compact;
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "MultiWriteNode",
      location: this.location,
      flags: this.#flags,
      lefts: this.lefts,
      rest: this.rest,
      rights: this.rights,
      lparenLoc: this.lparenLoc,
      rparenLoc: this.rparenLoc,
      operatorLoc: this.operatorLoc,
      value: this.value,
    };
  }
}

/**
 * Represents the use of the `next` keyword.
 *
 *     next 1
 *     ^^^^^^
 */
export class NextNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type ArgumentsNode | null
   */
  arguments_;

  /**
   * @type Location
   */
  keywordLoc;

  /**
   * Construct a new NextNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {ArgumentsNode | null} arguments_
   * @param {Location} keywordLoc
   */
  constructor(nodeID, location, flags, arguments_, keywordLoc) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.arguments_ = arguments_;
    this.keywordLoc = keywordLoc;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitNextNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.arguments_]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    const compact = [];

    if (this.arguments_) {
      compact.push(this.arguments_);
    }

    return compact;
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "NextNode",
      location: this.location,
      flags: this.#flags,
      arguments: this.arguments_,
      keywordLoc: this.keywordLoc,
    };
  }
}

/**
 * Represents the use of the `nil` keyword.
 *
 *     nil
 *     ^^^
 */
export class NilNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * Construct a new NilNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   */
  constructor(nodeID, location, flags) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitNilNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return []
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "NilNode",
      location: this.location,
      flags: this.#flags,
    };
  }
}

/**
 * Represents the use of `**nil` inside method arguments.
 *
 *     def a(**nil)
 *           ^^^^^
 *     end
 */
export class NoKeywordsParameterNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type Location
   */
  keywordLoc;

  /**
   * Construct a new NoKeywordsParameterNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Location} operatorLoc
   * @param {Location} keywordLoc
   */
  constructor(nodeID, location, flags, operatorLoc, keywordLoc) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.operatorLoc = operatorLoc;
    this.keywordLoc = keywordLoc;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitNoKeywordsParameterNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return []
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "NoKeywordsParameterNode",
      location: this.location,
      flags: this.#flags,
      operatorLoc: this.operatorLoc,
      keywordLoc: this.keywordLoc,
    };
  }
}

/**
 * Represents an implicit set of parameters through the use of numbered parameters within a block or lambda.
 *
 *     -> { _1 + _2 }
 *     ^^^^^^^^^^^^^^
 */
export class NumberedParametersNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type number
   */
  maximum;

  /**
   * Construct a new NumberedParametersNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {number} maximum
   */
  constructor(nodeID, location, flags, maximum) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.maximum = maximum;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitNumberedParametersNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return []
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "NumberedParametersNode",
      location: this.location,
      flags: this.#flags,
      maximum: this.maximum,
    };
  }
}

/**
 * Represents reading a numbered reference to a capture in the previous match.
 *
 *     $1
 *     ^^
 */
export class NumberedReferenceReadNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type number
   */
  number;

  /**
   * Construct a new NumberedReferenceReadNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {number} number
   */
  constructor(nodeID, location, flags, number) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.number = number;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitNumberedReferenceReadNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return []
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "NumberedReferenceReadNode",
      location: this.location,
      flags: this.#flags,
      number: this.number,
    };
  }
}

/**
 * Represents an optional keyword parameter to a method, block, or lambda definition.
 *
 *     def a(b: 1)
 *           ^^^^
 *     end
 */
export class OptionalKeywordParameterNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type string
   */
  name;

  /**
   * @type Location
   */
  nameLoc;

  /**
   * @type Node
   */
  value;

  /**
   * Construct a new OptionalKeywordParameterNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {string} name
   * @param {Location} nameLoc
   * @param {Node} value
   */
  constructor(nodeID, location, flags, name, nameLoc, value) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.name = name;
    this.nameLoc = nameLoc;
    this.value = value;
  }

  /**
   * True if this node has the REPEATED_PARAMETER flag.
   *
   * @returns {boolean}
   */
  isRepeatedParameter() {
    return (this.#flags & ParameterFlags.REPEATED_PARAMETER) !== 0;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitOptionalKeywordParameterNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.value]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [this.value];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "OptionalKeywordParameterNode",
      location: this.location,
      flags: this.#flags,
      name: this.name,
      nameLoc: this.nameLoc,
      value: this.value,
    };
  }
}

/**
 * Represents an optional parameter to a method, block, or lambda definition.
 *
 *     def a(b = 1)
 *           ^^^^^
 *     end
 */
export class OptionalParameterNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type string
   */
  name;

  /**
   * @type Location
   */
  nameLoc;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type Node
   */
  value;

  /**
   * Construct a new OptionalParameterNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {string} name
   * @param {Location} nameLoc
   * @param {Location} operatorLoc
   * @param {Node} value
   */
  constructor(nodeID, location, flags, name, nameLoc, operatorLoc, value) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.name = name;
    this.nameLoc = nameLoc;
    this.operatorLoc = operatorLoc;
    this.value = value;
  }

  /**
   * True if this node has the REPEATED_PARAMETER flag.
   *
   * @returns {boolean}
   */
  isRepeatedParameter() {
    return (this.#flags & ParameterFlags.REPEATED_PARAMETER) !== 0;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitOptionalParameterNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.value]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [this.value];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "OptionalParameterNode",
      location: this.location,
      flags: this.#flags,
      name: this.name,
      nameLoc: this.nameLoc,
      operatorLoc: this.operatorLoc,
      value: this.value,
    };
  }
}

/**
 * Represents the use of the `||` operator or the `or` keyword.
 *
 *     left or right
 *     ^^^^^^^^^^^^^
 */
export class OrNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Node
   */
  left;

  /**
   * @type Node
   */
  right;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * Construct a new OrNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Node} left
   * @param {Node} right
   * @param {Location} operatorLoc
   */
  constructor(nodeID, location, flags, left, right, operatorLoc) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.left = left;
    this.right = right;
    this.operatorLoc = operatorLoc;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitOrNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.left, this.right]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [this.left, this.right];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "OrNode",
      location: this.location,
      flags: this.#flags,
      left: this.left,
      right: this.right,
      operatorLoc: this.operatorLoc,
    };
  }
}

/**
 * Represents the list of parameters on a method, block, or lambda definition.
 *
 *     def a(b, c, d)
 *           ^^^^^^^
 *     end
 */
export class ParametersNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Node[]
   */
  requireds;

  /**
   * @type Node[]
   */
  optionals;

  /**
   * @type Node | null
   */
  rest;

  /**
   * @type Node[]
   */
  posts;

  /**
   * @type Node[]
   */
  keywords;

  /**
   * @type Node | null
   */
  keywordRest;

  /**
   * @type BlockParameterNode | null
   */
  block;

  /**
   * Construct a new ParametersNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Node[]} requireds
   * @param {Node[]} optionals
   * @param {Node | null} rest
   * @param {Node[]} posts
   * @param {Node[]} keywords
   * @param {Node | null} keywordRest
   * @param {BlockParameterNode | null} block
   */
  constructor(nodeID, location, flags, requireds, optionals, rest, posts, keywords, keywordRest, block) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.requireds = requireds;
    this.optionals = optionals;
    this.rest = rest;
    this.posts = posts;
    this.keywords = keywords;
    this.keywordRest = keywordRest;
    this.block = block;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitParametersNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [...this.requireds, ...this.optionals, this.rest, ...this.posts, ...this.keywords, this.keywordRest, this.block]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    const compact = [];

    compact.concat(this.requireds);
    compact.concat(this.optionals);
    if (this.rest) {
      compact.push(this.rest);
    }
    compact.concat(this.posts);
    compact.concat(this.keywords);
    if (this.keywordRest) {
      compact.push(this.keywordRest);
    }
    if (this.block) {
      compact.push(this.block);
    }

    return compact;
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "ParametersNode",
      location: this.location,
      flags: this.#flags,
      requireds: this.requireds,
      optionals: this.optionals,
      rest: this.rest,
      posts: this.posts,
      keywords: this.keywords,
      keywordRest: this.keywordRest,
      block: this.block,
    };
  }
}

/**
 * Represents a parenthesized expression
 *
 *     (10 + 34)
 *     ^^^^^^^^^
 */
export class ParenthesesNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Node | null
   */
  body;

  /**
   * @type Location
   */
  openingLoc;

  /**
   * @type Location
   */
  closingLoc;

  /**
   * Construct a new ParenthesesNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Node | null} body
   * @param {Location} openingLoc
   * @param {Location} closingLoc
   */
  constructor(nodeID, location, flags, body, openingLoc, closingLoc) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.body = body;
    this.openingLoc = openingLoc;
    this.closingLoc = closingLoc;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitParenthesesNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.body]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    const compact = [];

    if (this.body) {
      compact.push(this.body);
    }

    return compact;
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "ParenthesesNode",
      location: this.location,
      flags: this.#flags,
      body: this.body,
      openingLoc: this.openingLoc,
      closingLoc: this.closingLoc,
    };
  }
}

/**
 * Represents the use of the `^` operator for pinning an expression in a pattern matching expression.
 *
 *     foo in ^(bar)
 *            ^^^^^^
 */
export class PinnedExpressionNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Node
   */
  expression;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type Location
   */
  lparenLoc;

  /**
   * @type Location
   */
  rparenLoc;

  /**
   * Construct a new PinnedExpressionNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Node} expression
   * @param {Location} operatorLoc
   * @param {Location} lparenLoc
   * @param {Location} rparenLoc
   */
  constructor(nodeID, location, flags, expression, operatorLoc, lparenLoc, rparenLoc) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.expression = expression;
    this.operatorLoc = operatorLoc;
    this.lparenLoc = lparenLoc;
    this.rparenLoc = rparenLoc;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitPinnedExpressionNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.expression]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [this.expression];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "PinnedExpressionNode",
      location: this.location,
      flags: this.#flags,
      expression: this.expression,
      operatorLoc: this.operatorLoc,
      lparenLoc: this.lparenLoc,
      rparenLoc: this.rparenLoc,
    };
  }
}

/**
 * Represents the use of the `^` operator for pinning a variable in a pattern matching expression.
 *
 *     foo in ^bar
 *            ^^^^
 */
export class PinnedVariableNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Node
   */
  variable;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * Construct a new PinnedVariableNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Node} variable
   * @param {Location} operatorLoc
   */
  constructor(nodeID, location, flags, variable, operatorLoc) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.variable = variable;
    this.operatorLoc = operatorLoc;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitPinnedVariableNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.variable]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [this.variable];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "PinnedVariableNode",
      location: this.location,
      flags: this.#flags,
      variable: this.variable,
      operatorLoc: this.operatorLoc,
    };
  }
}

/**
 * Represents the use of the `END` keyword.
 *
 *     END { foo }
 *     ^^^^^^^^^^^
 */
export class PostExecutionNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type StatementsNode | null
   */
  statements;

  /**
   * @type Location
   */
  keywordLoc;

  /**
   * @type Location
   */
  openingLoc;

  /**
   * @type Location
   */
  closingLoc;

  /**
   * Construct a new PostExecutionNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {StatementsNode | null} statements
   * @param {Location} keywordLoc
   * @param {Location} openingLoc
   * @param {Location} closingLoc
   */
  constructor(nodeID, location, flags, statements, keywordLoc, openingLoc, closingLoc) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.statements = statements;
    this.keywordLoc = keywordLoc;
    this.openingLoc = openingLoc;
    this.closingLoc = closingLoc;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitPostExecutionNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.statements]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    const compact = [];

    if (this.statements) {
      compact.push(this.statements);
    }

    return compact;
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "PostExecutionNode",
      location: this.location,
      flags: this.#flags,
      statements: this.statements,
      keywordLoc: this.keywordLoc,
      openingLoc: this.openingLoc,
      closingLoc: this.closingLoc,
    };
  }
}

/**
 * Represents the use of the `BEGIN` keyword.
 *
 *     BEGIN { foo }
 *     ^^^^^^^^^^^^^
 */
export class PreExecutionNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type StatementsNode | null
   */
  statements;

  /**
   * @type Location
   */
  keywordLoc;

  /**
   * @type Location
   */
  openingLoc;

  /**
   * @type Location
   */
  closingLoc;

  /**
   * Construct a new PreExecutionNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {StatementsNode | null} statements
   * @param {Location} keywordLoc
   * @param {Location} openingLoc
   * @param {Location} closingLoc
   */
  constructor(nodeID, location, flags, statements, keywordLoc, openingLoc, closingLoc) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.statements = statements;
    this.keywordLoc = keywordLoc;
    this.openingLoc = openingLoc;
    this.closingLoc = closingLoc;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitPreExecutionNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.statements]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    const compact = [];

    if (this.statements) {
      compact.push(this.statements);
    }

    return compact;
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "PreExecutionNode",
      location: this.location,
      flags: this.#flags,
      statements: this.statements,
      keywordLoc: this.keywordLoc,
      openingLoc: this.openingLoc,
      closingLoc: this.closingLoc,
    };
  }
}

/**
 * The top level node of any parse tree.
 */
export class ProgramNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type string[]
   */
  locals;

  /**
   * @type StatementsNode
   */
  statements;

  /**
   * Construct a new ProgramNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {string[]} locals
   * @param {StatementsNode} statements
   */
  constructor(nodeID, location, flags, locals, statements) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.locals = locals;
    this.statements = statements;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitProgramNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.statements]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [this.statements];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "ProgramNode",
      location: this.location,
      flags: this.#flags,
      locals: this.locals,
      statements: this.statements,
    };
  }
}

/**
 * Represents the use of the `..` or `...` operators.
 *
 *     1..2
 *     ^^^^
 *
 *     c if a =~ /left/ ... b =~ /right/
 *          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 */
export class RangeNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Node | null
   */
  left;

  /**
   * @type Node | null
   */
  right;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * Construct a new RangeNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Node | null} left
   * @param {Node | null} right
   * @param {Location} operatorLoc
   */
  constructor(nodeID, location, flags, left, right, operatorLoc) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.left = left;
    this.right = right;
    this.operatorLoc = operatorLoc;
  }

  /**
   * True if this node has the EXCLUDE_END flag.
   *
   * @returns {boolean}
   */
  isExcludeEnd() {
    return (this.#flags & RangeFlags.EXCLUDE_END) !== 0;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitRangeNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.left, this.right]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    const compact = [];

    if (this.left) {
      compact.push(this.left);
    }
    if (this.right) {
      compact.push(this.right);
    }

    return compact;
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "RangeNode",
      location: this.location,
      flags: this.#flags,
      left: this.left,
      right: this.right,
      operatorLoc: this.operatorLoc,
    };
  }
}

/**
 * Represents a rational number literal.
 *
 *     1.0r
 *     ^^^^
 */
export class RationalNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type number
   */
  numerator;

  /**
   * @type number
   */
  denominator;

  /**
   * Construct a new RationalNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {number} numerator
   * @param {number} denominator
   */
  constructor(nodeID, location, flags, numerator, denominator) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.numerator = numerator;
    this.denominator = denominator;
  }

  /**
   * True if this node has the BINARY flag.
   *
   * @returns {boolean}
   */
  isBinary() {
    return (this.#flags & IntegerBaseFlags.BINARY) !== 0;
  }

  /**
   * True if this node has the DECIMAL flag.
   *
   * @returns {boolean}
   */
  isDecimal() {
    return (this.#flags & IntegerBaseFlags.DECIMAL) !== 0;
  }

  /**
   * True if this node has the OCTAL flag.
   *
   * @returns {boolean}
   */
  isOctal() {
    return (this.#flags & IntegerBaseFlags.OCTAL) !== 0;
  }

  /**
   * True if this node has the HEXADECIMAL flag.
   *
   * @returns {boolean}
   */
  isHexadecimal() {
    return (this.#flags & IntegerBaseFlags.HEXADECIMAL) !== 0;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitRationalNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return []
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "RationalNode",
      location: this.location,
      flags: this.#flags,
      numerator: this.numerator,
      denominator: this.denominator,
    };
  }
}

/**
 * Represents the use of the `redo` keyword.
 *
 *     redo
 *     ^^^^
 */
export class RedoNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * Construct a new RedoNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   */
  constructor(nodeID, location, flags) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitRedoNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return []
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "RedoNode",
      location: this.location,
      flags: this.#flags,
    };
  }
}

/**
 * Represents a regular expression literal with no interpolation.
 *
 *     /foo/i
 *     ^^^^^^
 */
export class RegularExpressionNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Location
   */
  openingLoc;

  /**
   * @type Location
   */
  contentLoc;

  /**
   * @type Location
   */
  closingLoc;

  /**
   * @type RubyString
   */
  unescaped;

  /**
   * Construct a new RegularExpressionNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Location} openingLoc
   * @param {Location} contentLoc
   * @param {Location} closingLoc
   * @param {RubyString} unescaped
   */
  constructor(nodeID, location, flags, openingLoc, contentLoc, closingLoc, unescaped) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.openingLoc = openingLoc;
    this.contentLoc = contentLoc;
    this.closingLoc = closingLoc;
    this.unescaped = unescaped;
  }

  /**
   * True if this node has the IGNORE_CASE flag.
   *
   * @returns {boolean}
   */
  isIgnoreCase() {
    return (this.#flags & RegularExpressionFlags.IGNORE_CASE) !== 0;
  }

  /**
   * True if this node has the EXTENDED flag.
   *
   * @returns {boolean}
   */
  isExtended() {
    return (this.#flags & RegularExpressionFlags.EXTENDED) !== 0;
  }

  /**
   * True if this node has the MULTI_LINE flag.
   *
   * @returns {boolean}
   */
  isMultiLine() {
    return (this.#flags & RegularExpressionFlags.MULTI_LINE) !== 0;
  }

  /**
   * True if this node has the ONCE flag.
   *
   * @returns {boolean}
   */
  isOnce() {
    return (this.#flags & RegularExpressionFlags.ONCE) !== 0;
  }

  /**
   * True if this node has the EUC_JP flag.
   *
   * @returns {boolean}
   */
  isEucJp() {
    return (this.#flags & RegularExpressionFlags.EUC_JP) !== 0;
  }

  /**
   * True if this node has the ASCII_8BIT flag.
   *
   * @returns {boolean}
   */
  isAscii8bit() {
    return (this.#flags & RegularExpressionFlags.ASCII_8BIT) !== 0;
  }

  /**
   * True if this node has the WINDOWS_31J flag.
   *
   * @returns {boolean}
   */
  isWindows31j() {
    return (this.#flags & RegularExpressionFlags.WINDOWS_31J) !== 0;
  }

  /**
   * True if this node has the UTF_8 flag.
   *
   * @returns {boolean}
   */
  isUtf8() {
    return (this.#flags & RegularExpressionFlags.UTF_8) !== 0;
  }

  /**
   * True if this node has the FORCED_UTF8_ENCODING flag.
   *
   * @returns {boolean}
   */
  isForcedUtf8Encoding() {
    return (this.#flags & RegularExpressionFlags.FORCED_UTF8_ENCODING) !== 0;
  }

  /**
   * True if this node has the FORCED_BINARY_ENCODING flag.
   *
   * @returns {boolean}
   */
  isForcedBinaryEncoding() {
    return (this.#flags & RegularExpressionFlags.FORCED_BINARY_ENCODING) !== 0;
  }

  /**
   * True if this node has the FORCED_US_ASCII_ENCODING flag.
   *
   * @returns {boolean}
   */
  isForcedUsAsciiEncoding() {
    return (this.#flags & RegularExpressionFlags.FORCED_US_ASCII_ENCODING) !== 0;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitRegularExpressionNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return []
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "RegularExpressionNode",
      location: this.location,
      flags: this.#flags,
      openingLoc: this.openingLoc,
      contentLoc: this.contentLoc,
      closingLoc: this.closingLoc,
      unescaped: this.unescaped,
    };
  }
}

/**
 * Represents a required keyword parameter to a method, block, or lambda definition.
 *
 *     def a(b: )
 *           ^^
 *     end
 */
export class RequiredKeywordParameterNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type string
   */
  name;

  /**
   * @type Location
   */
  nameLoc;

  /**
   * Construct a new RequiredKeywordParameterNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {string} name
   * @param {Location} nameLoc
   */
  constructor(nodeID, location, flags, name, nameLoc) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.name = name;
    this.nameLoc = nameLoc;
  }

  /**
   * True if this node has the REPEATED_PARAMETER flag.
   *
   * @returns {boolean}
   */
  isRepeatedParameter() {
    return (this.#flags & ParameterFlags.REPEATED_PARAMETER) !== 0;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitRequiredKeywordParameterNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return []
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "RequiredKeywordParameterNode",
      location: this.location,
      flags: this.#flags,
      name: this.name,
      nameLoc: this.nameLoc,
    };
  }
}

/**
 * Represents a required parameter to a method, block, or lambda definition.
 *
 *     def a(b)
 *           ^
 *     end
 */
export class RequiredParameterNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type string
   */
  name;

  /**
   * Construct a new RequiredParameterNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {string} name
   */
  constructor(nodeID, location, flags, name) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.name = name;
  }

  /**
   * True if this node has the REPEATED_PARAMETER flag.
   *
   * @returns {boolean}
   */
  isRepeatedParameter() {
    return (this.#flags & ParameterFlags.REPEATED_PARAMETER) !== 0;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitRequiredParameterNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return []
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "RequiredParameterNode",
      location: this.location,
      flags: this.#flags,
      name: this.name,
    };
  }
}

/**
 * Represents an expression modified with a rescue.
 *
 *     foo rescue nil
 *     ^^^^^^^^^^^^^^
 */
export class RescueModifierNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Node
   */
  expression;

  /**
   * @type Location
   */
  keywordLoc;

  /**
   * @type Node
   */
  rescueExpression;

  /**
   * Construct a new RescueModifierNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Node} expression
   * @param {Location} keywordLoc
   * @param {Node} rescueExpression
   */
  constructor(nodeID, location, flags, expression, keywordLoc, rescueExpression) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.expression = expression;
    this.keywordLoc = keywordLoc;
    this.rescueExpression = rescueExpression;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitRescueModifierNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.expression, this.rescueExpression]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [this.expression, this.rescueExpression];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "RescueModifierNode",
      location: this.location,
      flags: this.#flags,
      expression: this.expression,
      keywordLoc: this.keywordLoc,
      rescueExpression: this.rescueExpression,
    };
  }
}

/**
 * Represents a rescue statement.
 *
 *     begin
 *     rescue Foo, *splat, Bar => ex
 *       foo
 *     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 *     end
 *
 * `Foo, *splat, Bar` are in the `exceptions` field. `ex` is in the `exception` field.
 */
export class RescueNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Location
   */
  keywordLoc;

  /**
   * @type Node[]
   */
  exceptions;

  /**
   * @type Location | null
   */
  operatorLoc;

  /**
   * @type Node | null
   */
  reference;

  /**
   * @type StatementsNode | null
   */
  statements;

  /**
   * @type RescueNode | null
   */
  subsequent;

  /**
   * Construct a new RescueNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Location} keywordLoc
   * @param {Node[]} exceptions
   * @param {Location | null} operatorLoc
   * @param {Node | null} reference
   * @param {StatementsNode | null} statements
   * @param {RescueNode | null} subsequent
   */
  constructor(nodeID, location, flags, keywordLoc, exceptions, operatorLoc, reference, statements, subsequent) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.keywordLoc = keywordLoc;
    this.exceptions = exceptions;
    this.operatorLoc = operatorLoc;
    this.reference = reference;
    this.statements = statements;
    this.subsequent = subsequent;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitRescueNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [...this.exceptions, this.reference, this.statements, this.subsequent]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    const compact = [];

    compact.concat(this.exceptions);
    if (this.reference) {
      compact.push(this.reference);
    }
    if (this.statements) {
      compact.push(this.statements);
    }
    if (this.subsequent) {
      compact.push(this.subsequent);
    }

    return compact;
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "RescueNode",
      location: this.location,
      flags: this.#flags,
      keywordLoc: this.keywordLoc,
      exceptions: this.exceptions,
      operatorLoc: this.operatorLoc,
      reference: this.reference,
      statements: this.statements,
      subsequent: this.subsequent,
    };
  }
}

/**
 * Represents a rest parameter to a method, block, or lambda definition.
 *
 *     def a(*b)
 *           ^^
 *     end
 */
export class RestParameterNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type string | null
   */
  name;

  /**
   * @type Location | null
   */
  nameLoc;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * Construct a new RestParameterNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {string | null} name
   * @param {Location | null} nameLoc
   * @param {Location} operatorLoc
   */
  constructor(nodeID, location, flags, name, nameLoc, operatorLoc) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.name = name;
    this.nameLoc = nameLoc;
    this.operatorLoc = operatorLoc;
  }

  /**
   * True if this node has the REPEATED_PARAMETER flag.
   *
   * @returns {boolean}
   */
  isRepeatedParameter() {
    return (this.#flags & ParameterFlags.REPEATED_PARAMETER) !== 0;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitRestParameterNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return []
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "RestParameterNode",
      location: this.location,
      flags: this.#flags,
      name: this.name,
      nameLoc: this.nameLoc,
      operatorLoc: this.operatorLoc,
    };
  }
}

/**
 * Represents the use of the `retry` keyword.
 *
 *     retry
 *     ^^^^^
 */
export class RetryNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * Construct a new RetryNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   */
  constructor(nodeID, location, flags) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitRetryNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return []
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "RetryNode",
      location: this.location,
      flags: this.#flags,
    };
  }
}

/**
 * Represents the use of the `return` keyword.
 *
 *     return 1
 *     ^^^^^^^^
 */
export class ReturnNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Location
   */
  keywordLoc;

  /**
   * @type ArgumentsNode | null
   */
  arguments_;

  /**
   * Construct a new ReturnNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Location} keywordLoc
   * @param {ArgumentsNode | null} arguments_
   */
  constructor(nodeID, location, flags, keywordLoc, arguments_) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.keywordLoc = keywordLoc;
    this.arguments_ = arguments_;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitReturnNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.arguments_]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    const compact = [];

    if (this.arguments_) {
      compact.push(this.arguments_);
    }

    return compact;
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "ReturnNode",
      location: this.location,
      flags: this.#flags,
      keywordLoc: this.keywordLoc,
      arguments: this.arguments_,
    };
  }
}

/**
 * Represents the `self` keyword.
 *
 *     self
 *     ^^^^
 */
export class SelfNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * Construct a new SelfNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   */
  constructor(nodeID, location, flags) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitSelfNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return []
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "SelfNode",
      location: this.location,
      flags: this.#flags,
    };
  }
}

/**
 * This node wraps a constant write to indicate that when the value is written, it should have its shareability state modified.
 *
 *     # shareable_constant_value: literal
 *     C = { a: 1 }
 *     ^^^^^^^^^^^^
 */
export class ShareableConstantNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Node
   */
  write;

  /**
   * Construct a new ShareableConstantNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Node} write
   */
  constructor(nodeID, location, flags, write) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.write = write;
  }

  /**
   * True if this node has the LITERAL flag.
   *
   * @returns {boolean}
   */
  isLiteral() {
    return (this.#flags & ShareableConstantNodeFlags.LITERAL) !== 0;
  }

  /**
   * True if this node has the EXPERIMENTAL_EVERYTHING flag.
   *
   * @returns {boolean}
   */
  isExperimentalEverything() {
    return (this.#flags & ShareableConstantNodeFlags.EXPERIMENTAL_EVERYTHING) !== 0;
  }

  /**
   * True if this node has the EXPERIMENTAL_COPY flag.
   *
   * @returns {boolean}
   */
  isExperimentalCopy() {
    return (this.#flags & ShareableConstantNodeFlags.EXPERIMENTAL_COPY) !== 0;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitShareableConstantNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.write]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [this.write];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "ShareableConstantNode",
      location: this.location,
      flags: this.#flags,
      write: this.write,
    };
  }
}

/**
 * Represents a singleton class declaration involving the `class` keyword.
 *
 *     class << self end
 *     ^^^^^^^^^^^^^^^^^
 */
export class SingletonClassNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type string[]
   */
  locals;

  /**
   * @type Location
   */
  classKeywordLoc;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type Node
   */
  expression;

  /**
   * @type Node | null
   */
  body;

  /**
   * @type Location
   */
  endKeywordLoc;

  /**
   * Construct a new SingletonClassNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {string[]} locals
   * @param {Location} classKeywordLoc
   * @param {Location} operatorLoc
   * @param {Node} expression
   * @param {Node | null} body
   * @param {Location} endKeywordLoc
   */
  constructor(nodeID, location, flags, locals, classKeywordLoc, operatorLoc, expression, body, endKeywordLoc) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.locals = locals;
    this.classKeywordLoc = classKeywordLoc;
    this.operatorLoc = operatorLoc;
    this.expression = expression;
    this.body = body;
    this.endKeywordLoc = endKeywordLoc;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitSingletonClassNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.expression, this.body]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    const compact = [];

    compact.push(this.expression);

    if (this.body) {
      compact.push(this.body);
    }

    return compact;
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "SingletonClassNode",
      location: this.location,
      flags: this.#flags,
      locals: this.locals,
      classKeywordLoc: this.classKeywordLoc,
      operatorLoc: this.operatorLoc,
      expression: this.expression,
      body: this.body,
      endKeywordLoc: this.endKeywordLoc,
    };
  }
}

/**
 * Represents the use of the `__ENCODING__` keyword.
 *
 *     __ENCODING__
 *     ^^^^^^^^^^^^
 */
export class SourceEncodingNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * Construct a new SourceEncodingNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   */
  constructor(nodeID, location, flags) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitSourceEncodingNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return []
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "SourceEncodingNode",
      location: this.location,
      flags: this.#flags,
    };
  }
}

/**
 * Represents the use of the `__FILE__` keyword.
 *
 *     __FILE__
 *     ^^^^^^^^
 */
export class SourceFileNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type RubyString
   */
  filepath;

  /**
   * Construct a new SourceFileNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {RubyString} filepath
   */
  constructor(nodeID, location, flags, filepath) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.filepath = filepath;
  }

  /**
   * True if this node has the FORCED_UTF8_ENCODING flag.
   *
   * @returns {boolean}
   */
  isForcedUtf8Encoding() {
    return (this.#flags & StringFlags.FORCED_UTF8_ENCODING) !== 0;
  }

  /**
   * True if this node has the FORCED_BINARY_ENCODING flag.
   *
   * @returns {boolean}
   */
  isForcedBinaryEncoding() {
    return (this.#flags & StringFlags.FORCED_BINARY_ENCODING) !== 0;
  }

  /**
   * True if this node has the FROZEN flag.
   *
   * @returns {boolean}
   */
  isFrozen() {
    return (this.#flags & StringFlags.FROZEN) !== 0;
  }

  /**
   * True if this node has the MUTABLE flag.
   *
   * @returns {boolean}
   */
  isMutable() {
    return (this.#flags & StringFlags.MUTABLE) !== 0;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitSourceFileNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return []
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "SourceFileNode",
      location: this.location,
      flags: this.#flags,
      filepath: this.filepath,
    };
  }
}

/**
 * Represents the use of the `__LINE__` keyword.
 *
 *     __LINE__
 *     ^^^^^^^^
 */
export class SourceLineNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * Construct a new SourceLineNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   */
  constructor(nodeID, location, flags) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitSourceLineNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return []
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "SourceLineNode",
      location: this.location,
      flags: this.#flags,
    };
  }
}

/**
 * Represents the use of the splat operator.
 *
 *     [*a]
 *      ^^
 */
export class SplatNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Location
   */
  operatorLoc;

  /**
   * @type Node | null
   */
  expression;

  /**
   * Construct a new SplatNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Location} operatorLoc
   * @param {Node | null} expression
   */
  constructor(nodeID, location, flags, operatorLoc, expression) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.operatorLoc = operatorLoc;
    this.expression = expression;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitSplatNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.expression]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    const compact = [];

    if (this.expression) {
      compact.push(this.expression);
    }

    return compact;
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "SplatNode",
      location: this.location,
      flags: this.#flags,
      operatorLoc: this.operatorLoc,
      expression: this.expression,
    };
  }
}

/**
 * Represents a set of statements contained within some scope.
 *
 *     foo; bar; baz
 *     ^^^^^^^^^^^^^
 */
export class StatementsNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Node[]
   */
  body;

  /**
   * Construct a new StatementsNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Node[]} body
   */
  constructor(nodeID, location, flags, body) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.body = body;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitStatementsNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [...this.body]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [...this.body];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "StatementsNode",
      location: this.location,
      flags: this.#flags,
      body: this.body,
    };
  }
}

/**
 * Represents a string literal, a string contained within a `%w` list, or plain string content within an interpolated string.
 *
 *     "foo"
 *     ^^^^^
 *
 *     %w[foo]
 *        ^^^
 *
 *     "foo #{bar} baz"
 *      ^^^^      ^^^^
 */
export class StringNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Location | null
   */
  openingLoc;

  /**
   * @type Location
   */
  contentLoc;

  /**
   * @type Location | null
   */
  closingLoc;

  /**
   * @type RubyString
   */
  unescaped;

  /**
   * Construct a new StringNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Location | null} openingLoc
   * @param {Location} contentLoc
   * @param {Location | null} closingLoc
   * @param {RubyString} unescaped
   */
  constructor(nodeID, location, flags, openingLoc, contentLoc, closingLoc, unescaped) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.openingLoc = openingLoc;
    this.contentLoc = contentLoc;
    this.closingLoc = closingLoc;
    this.unescaped = unescaped;
  }

  /**
   * True if this node has the FORCED_UTF8_ENCODING flag.
   *
   * @returns {boolean}
   */
  isForcedUtf8Encoding() {
    return (this.#flags & StringFlags.FORCED_UTF8_ENCODING) !== 0;
  }

  /**
   * True if this node has the FORCED_BINARY_ENCODING flag.
   *
   * @returns {boolean}
   */
  isForcedBinaryEncoding() {
    return (this.#flags & StringFlags.FORCED_BINARY_ENCODING) !== 0;
  }

  /**
   * True if this node has the FROZEN flag.
   *
   * @returns {boolean}
   */
  isFrozen() {
    return (this.#flags & StringFlags.FROZEN) !== 0;
  }

  /**
   * True if this node has the MUTABLE flag.
   *
   * @returns {boolean}
   */
  isMutable() {
    return (this.#flags & StringFlags.MUTABLE) !== 0;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitStringNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return []
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "StringNode",
      location: this.location,
      flags: this.#flags,
      openingLoc: this.openingLoc,
      contentLoc: this.contentLoc,
      closingLoc: this.closingLoc,
      unescaped: this.unescaped,
    };
  }
}

/**
 * Represents the use of the `super` keyword with parentheses or arguments.
 *
 *     super()
 *     ^^^^^^^
 *
 *     super foo, bar
 *     ^^^^^^^^^^^^^^
 */
export class SuperNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Location
   */
  keywordLoc;

  /**
   * @type Location | null
   */
  lparenLoc;

  /**
   * @type ArgumentsNode | null
   */
  arguments_;

  /**
   * @type Location | null
   */
  rparenLoc;

  /**
   * @type Node | null
   */
  block;

  /**
   * Construct a new SuperNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Location} keywordLoc
   * @param {Location | null} lparenLoc
   * @param {ArgumentsNode | null} arguments_
   * @param {Location | null} rparenLoc
   * @param {Node | null} block
   */
  constructor(nodeID, location, flags, keywordLoc, lparenLoc, arguments_, rparenLoc, block) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.keywordLoc = keywordLoc;
    this.lparenLoc = lparenLoc;
    this.arguments_ = arguments_;
    this.rparenLoc = rparenLoc;
    this.block = block;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitSuperNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.arguments_, this.block]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    const compact = [];

    if (this.arguments_) {
      compact.push(this.arguments_);
    }
    if (this.block) {
      compact.push(this.block);
    }

    return compact;
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "SuperNode",
      location: this.location,
      flags: this.#flags,
      keywordLoc: this.keywordLoc,
      lparenLoc: this.lparenLoc,
      arguments: this.arguments_,
      rparenLoc: this.rparenLoc,
      block: this.block,
    };
  }
}

/**
 * Represents a symbol literal or a symbol contained within a `%i` list.
 *
 *     :foo
 *     ^^^^
 *
 *     %i[foo]
 *        ^^^
 */
export class SymbolNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Location | null
   */
  openingLoc;

  /**
   * @type Location | null
   */
  valueLoc;

  /**
   * @type Location | null
   */
  closingLoc;

  /**
   * @type RubyString
   */
  unescaped;

  /**
   * Construct a new SymbolNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Location | null} openingLoc
   * @param {Location | null} valueLoc
   * @param {Location | null} closingLoc
   * @param {RubyString} unescaped
   */
  constructor(nodeID, location, flags, openingLoc, valueLoc, closingLoc, unescaped) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.openingLoc = openingLoc;
    this.valueLoc = valueLoc;
    this.closingLoc = closingLoc;
    this.unescaped = unescaped;
  }

  /**
   * True if this node has the FORCED_UTF8_ENCODING flag.
   *
   * @returns {boolean}
   */
  isForcedUtf8Encoding() {
    return (this.#flags & SymbolFlags.FORCED_UTF8_ENCODING) !== 0;
  }

  /**
   * True if this node has the FORCED_BINARY_ENCODING flag.
   *
   * @returns {boolean}
   */
  isForcedBinaryEncoding() {
    return (this.#flags & SymbolFlags.FORCED_BINARY_ENCODING) !== 0;
  }

  /**
   * True if this node has the FORCED_US_ASCII_ENCODING flag.
   *
   * @returns {boolean}
   */
  isForcedUsAsciiEncoding() {
    return (this.#flags & SymbolFlags.FORCED_US_ASCII_ENCODING) !== 0;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitSymbolNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return []
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "SymbolNode",
      location: this.location,
      flags: this.#flags,
      openingLoc: this.openingLoc,
      valueLoc: this.valueLoc,
      closingLoc: this.closingLoc,
      unescaped: this.unescaped,
    };
  }
}

/**
 * Represents the use of the literal `true` keyword.
 *
 *     true
 *     ^^^^
 */
export class TrueNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * Construct a new TrueNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   */
  constructor(nodeID, location, flags) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitTrueNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return []
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "TrueNode",
      location: this.location,
      flags: this.#flags,
    };
  }
}

/**
 * Represents the use of the `undef` keyword.
 *
 *     undef :foo, :bar, :baz
 *     ^^^^^^^^^^^^^^^^^^^^^^
 */
export class UndefNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Node[]
   */
  names;

  /**
   * @type Location
   */
  keywordLoc;

  /**
   * Construct a new UndefNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Node[]} names
   * @param {Location} keywordLoc
   */
  constructor(nodeID, location, flags, names, keywordLoc) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.names = names;
    this.keywordLoc = keywordLoc;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitUndefNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [...this.names]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [...this.names];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "UndefNode",
      location: this.location,
      flags: this.#flags,
      names: this.names,
      keywordLoc: this.keywordLoc,
    };
  }
}

/**
 * Represents the use of the `unless` keyword, either in the block form or the modifier form.
 *
 *     bar unless foo
 *     ^^^^^^^^^^^^^^
 *
 *     unless foo then bar end
 *     ^^^^^^^^^^^^^^^^^^^^^^^
 */
export class UnlessNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Location
   */
  keywordLoc;

  /**
   * @type Node
   */
  predicate;

  /**
   * @type Location | null
   */
  thenKeywordLoc;

  /**
   * @type StatementsNode | null
   */
  statements;

  /**
   * @type ElseNode | null
   */
  elseClause;

  /**
   * @type Location | null
   */
  endKeywordLoc;

  /**
   * Construct a new UnlessNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Location} keywordLoc
   * @param {Node} predicate
   * @param {Location | null} thenKeywordLoc
   * @param {StatementsNode | null} statements
   * @param {ElseNode | null} elseClause
   * @param {Location | null} endKeywordLoc
   */
  constructor(nodeID, location, flags, keywordLoc, predicate, thenKeywordLoc, statements, elseClause, endKeywordLoc) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.keywordLoc = keywordLoc;
    this.predicate = predicate;
    this.thenKeywordLoc = thenKeywordLoc;
    this.statements = statements;
    this.elseClause = elseClause;
    this.endKeywordLoc = endKeywordLoc;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitUnlessNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.predicate, this.statements, this.elseClause]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    const compact = [];

    compact.push(this.predicate);

    if (this.statements) {
      compact.push(this.statements);
    }
    if (this.elseClause) {
      compact.push(this.elseClause);
    }

    return compact;
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "UnlessNode",
      location: this.location,
      flags: this.#flags,
      keywordLoc: this.keywordLoc,
      predicate: this.predicate,
      thenKeywordLoc: this.thenKeywordLoc,
      statements: this.statements,
      elseClause: this.elseClause,
      endKeywordLoc: this.endKeywordLoc,
    };
  }
}

/**
 * Represents the use of the `until` keyword, either in the block form or the modifier form.
 *
 *     bar until foo
 *     ^^^^^^^^^^^^^
 *
 *     until foo do bar end
 *     ^^^^^^^^^^^^^^^^^^^^
 */
export class UntilNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Location
   */
  keywordLoc;

  /**
   * @type Location | null
   */
  closingLoc;

  /**
   * @type Node
   */
  predicate;

  /**
   * @type StatementsNode | null
   */
  statements;

  /**
   * Construct a new UntilNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Location} keywordLoc
   * @param {Location | null} closingLoc
   * @param {Node} predicate
   * @param {StatementsNode | null} statements
   */
  constructor(nodeID, location, flags, keywordLoc, closingLoc, predicate, statements) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.keywordLoc = keywordLoc;
    this.closingLoc = closingLoc;
    this.predicate = predicate;
    this.statements = statements;
  }

  /**
   * True if this node has the BEGIN_MODIFIER flag.
   *
   * @returns {boolean}
   */
  isBeginModifier() {
    return (this.#flags & LoopFlags.BEGIN_MODIFIER) !== 0;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitUntilNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.predicate, this.statements]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    const compact = [];

    compact.push(this.predicate);

    if (this.statements) {
      compact.push(this.statements);
    }

    return compact;
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "UntilNode",
      location: this.location,
      flags: this.#flags,
      keywordLoc: this.keywordLoc,
      closingLoc: this.closingLoc,
      predicate: this.predicate,
      statements: this.statements,
    };
  }
}

/**
 * Represents the use of the `when` keyword within a case statement.
 *
 *     case true
 *     when true
 *     ^^^^^^^^^
 *     end
 */
export class WhenNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Location
   */
  keywordLoc;

  /**
   * @type Node[]
   */
  conditions;

  /**
   * @type Location | null
   */
  thenKeywordLoc;

  /**
   * @type StatementsNode | null
   */
  statements;

  /**
   * Construct a new WhenNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Location} keywordLoc
   * @param {Node[]} conditions
   * @param {Location | null} thenKeywordLoc
   * @param {StatementsNode | null} statements
   */
  constructor(nodeID, location, flags, keywordLoc, conditions, thenKeywordLoc, statements) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.keywordLoc = keywordLoc;
    this.conditions = conditions;
    this.thenKeywordLoc = thenKeywordLoc;
    this.statements = statements;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitWhenNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [...this.conditions, this.statements]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    const compact = [];

    compact.concat(this.conditions);
    if (this.statements) {
      compact.push(this.statements);
    }

    return compact;
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "WhenNode",
      location: this.location,
      flags: this.#flags,
      keywordLoc: this.keywordLoc,
      conditions: this.conditions,
      thenKeywordLoc: this.thenKeywordLoc,
      statements: this.statements,
    };
  }
}

/**
 * Represents the use of the `while` keyword, either in the block form or the modifier form.
 *
 *     bar while foo
 *     ^^^^^^^^^^^^^
 *
 *     while foo do bar end
 *     ^^^^^^^^^^^^^^^^^^^^
 */
export class WhileNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Location
   */
  keywordLoc;

  /**
   * @type Location | null
   */
  closingLoc;

  /**
   * @type Node
   */
  predicate;

  /**
   * @type StatementsNode | null
   */
  statements;

  /**
   * Construct a new WhileNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Location} keywordLoc
   * @param {Location | null} closingLoc
   * @param {Node} predicate
   * @param {StatementsNode | null} statements
   */
  constructor(nodeID, location, flags, keywordLoc, closingLoc, predicate, statements) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.keywordLoc = keywordLoc;
    this.closingLoc = closingLoc;
    this.predicate = predicate;
    this.statements = statements;
  }

  /**
   * True if this node has the BEGIN_MODIFIER flag.
   *
   * @returns {boolean}
   */
  isBeginModifier() {
    return (this.#flags & LoopFlags.BEGIN_MODIFIER) !== 0;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitWhileNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.predicate, this.statements]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    const compact = [];

    compact.push(this.predicate);

    if (this.statements) {
      compact.push(this.statements);
    }

    return compact;
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "WhileNode",
      location: this.location,
      flags: this.#flags,
      keywordLoc: this.keywordLoc,
      closingLoc: this.closingLoc,
      predicate: this.predicate,
      statements: this.statements,
    };
  }
}

/**
 * Represents an xstring literal with no interpolation.
 *
 *     `foo`
 *     ^^^^^
 */
export class XStringNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Location
   */
  openingLoc;

  /**
   * @type Location
   */
  contentLoc;

  /**
   * @type Location
   */
  closingLoc;

  /**
   * @type RubyString
   */
  unescaped;

  /**
   * Construct a new XStringNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Location} openingLoc
   * @param {Location} contentLoc
   * @param {Location} closingLoc
   * @param {RubyString} unescaped
   */
  constructor(nodeID, location, flags, openingLoc, contentLoc, closingLoc, unescaped) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.openingLoc = openingLoc;
    this.contentLoc = contentLoc;
    this.closingLoc = closingLoc;
    this.unescaped = unescaped;
  }

  /**
   * True if this node has the FORCED_UTF8_ENCODING flag.
   *
   * @returns {boolean}
   */
  isForcedUtf8Encoding() {
    return (this.#flags & EncodingFlags.FORCED_UTF8_ENCODING) !== 0;
  }

  /**
   * True if this node has the FORCED_BINARY_ENCODING flag.
   *
   * @returns {boolean}
   */
  isForcedBinaryEncoding() {
    return (this.#flags & EncodingFlags.FORCED_BINARY_ENCODING) !== 0;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitXStringNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return []
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    return [];
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "XStringNode",
      location: this.location,
      flags: this.#flags,
      openingLoc: this.openingLoc,
      contentLoc: this.contentLoc,
      closingLoc: this.closingLoc,
      unescaped: this.unescaped,
    };
  }
}

/**
 * Represents the use of the `yield` keyword.
 *
 *     yield 1
 *     ^^^^^^^
 */
export class YieldNode {
  /**
   * @type {Integer}
   */
  nodeID;

  /**
   * @type {Location}
   */
  location;

  /**
   * @type number
   */
  #flags;

  /**
   * @type Location
   */
  keywordLoc;

  /**
   * @type Location | null
   */
  lparenLoc;

  /**
   * @type ArgumentsNode | null
   */
  arguments_;

  /**
   * @type Location | null
   */
  rparenLoc;

  /**
   * Construct a new YieldNode.
   *
   * @param {number} nodeID
   * @param {Location} location
   * @param {number} flags
   * @param {Location} keywordLoc
   * @param {Location | null} lparenLoc
   * @param {ArgumentsNode | null} arguments_
   * @param {Location | null} rparenLoc
   */
  constructor(nodeID, location, flags, keywordLoc, lparenLoc, arguments_, rparenLoc) {
    this.nodeID = nodeID;
    this.location = location;
    this.#flags = flags;
    this.keywordLoc = keywordLoc;
    this.lparenLoc = lparenLoc;
    this.arguments_ = arguments_;
    this.rparenLoc = rparenLoc;
  }

  /**
   * Accept a visitor for this node.
   *
   * @param {visitors.Visitor} visitor
   */
  accept(visitor) {
    visitor.visitYieldNode(this)
  }

  /**
   * Returns all child nodes of the current node.
   *
   * @returns {(Node | null)[]} An array of child nodes.
   */
  childNodes() {
    return [this.arguments_]
  }

  /**
   * Compact and return an array of child nodes.
   *
   * @returns {Node[]} An array of compacted child nodes.
   */
  compactChildNodes() {
    const compact = [];

    if (this.arguments_) {
      compact.push(this.arguments_);
    }

    return compact;
  }

  /**
   * Transforms the Node to a JavaScript object.
   *
   * @returns {Object}
   */
  toJSON() {
    return {
      type: "YieldNode",
      location: this.location,
      flags: this.#flags,
      keywordLoc: this.keywordLoc,
      lparenLoc: this.lparenLoc,
      arguments: this.arguments_,
      rparenLoc: this.rparenLoc,
    };
  }
}
